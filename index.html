<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IconX - Hero Arena</title>
    <!-- Cloud-based multiplayer - no PeerJS needed -->
    <style>
        /* Login Screen */
        #loginScreen {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        #loginScreen .title {
            font-size: 48px;
            margin-bottom: 5px;
        }

        #loginScreen .subtitle {
            margin-bottom: 20px;
        }

        .login-container {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #ff6b35;
            border-radius: 20px;
            padding: 25px;
            max-width: 350px;
            width: 100%;
        }

        .login-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
        }

        .login-tab {
            flex: 1;
            padding: 10px 8px;
            border: 2px solid #333;
            border-radius: 8px;
            background: transparent;
            color: #888;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .login-tab.active {
            border-color: #ff6b35;
            color: #ff6b35;
            background: rgba(255, 107, 53, 0.1);
        }

        .login-form {
            display: none;
        }

        .login-form.active {
            display: block;
        }

        .server-status {
            position: fixed;
            top: 20px;
            left: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: rgba(20, 20, 40, 0.95);
            border-radius: 20px;
            font-size: 12px;
            z-index: 100;
        }

        .server-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
        }

        .server-status-dot.connected {
            background: #44ff88;
        }

        .server-status-dot.connecting {
            background: #f7c531;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0a0a1a 0%, #1a1a3a 50%, #0a0a1a 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            min-height: 100vh;
            overflow: hidden;
        }

        #menu {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .title {
            font-size: 72px;
            font-weight: bold;
            background: linear-gradient(45deg, #ff6b35, #f7c531, #ff6b35);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 50px rgba(255, 107, 53, 0.5);
            margin-bottom: 10px;
            letter-spacing: 8px;
        }

        .subtitle {
            font-size: 18px;
            color: #888;
            margin-bottom: 40px;
            letter-spacing: 4px;
        }

        /* Currency Display */
        .currency-display {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #f7c531;
            border-radius: 25px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(247, 197, 49, 0.3);
        }

        .currency-icon {
            font-size: 24px;
        }

        .currency-amount {
            font-size: 20px;
            font-weight: bold;
            color: #f7c531;
        }

        /* Menu Buttons Row */
        .menu-buttons-row {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .btn-icon {
            width: 50px;
            height: 50px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #333;
            background: rgba(0, 0, 0, 0.5);
        }

        .btn-icon:hover {
            transform: scale(1.1);
            border-color: #ff6b35;
        }

        .btn-icon.shop { border-color: #f7c531; }
        .btn-icon.quests { border-color: #44ff88; }
        .btn-icon.skins { border-color: #ff44aa; }

        /* Shop Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(180deg, rgba(30, 30, 60, 0.98) 0%, rgba(15, 15, 30, 0.98) 100%);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 30px;
            max-width: 900px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #333;
        }

        .modal-title {
            font-size: 28px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .modal-close {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ff4444;
            background: transparent;
            color: #ff4444;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: #ff4444;
            color: #fff;
        }

        /* Shop Items */
        .shop-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .shop-tab {
            padding: 10px 20px;
            border: 2px solid #333;
            border-radius: 10px;
            background: transparent;
            color: #888;
            cursor: pointer;
            transition: all 0.3s;
        }

        .shop-tab.active {
            border-color: #f7c531;
            color: #f7c531;
            background: rgba(247, 197, 49, 0.1);
        }

        .skins-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
        }

        .skin-card {
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid #333;
            border-radius: 15px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .skin-card:hover {
            transform: translateY(-5px);
            border-color: #666;
        }

        .skin-card.owned {
            border-color: #44ff88;
        }

        .skin-card.equipped {
            border-color: #f7c531;
            box-shadow: 0 0 20px rgba(247, 197, 49, 0.3);
        }

        .skin-card.locked {
            opacity: 0.7;
        }

        .skin-preview {
            width: 80px;
            height: 80px;
            margin: 0 auto 10px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .skin-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .skin-rarity {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .skin-rarity.common { color: #888; }
        .skin-rarity.rare { color: #44aaff; }
        .skin-rarity.epic { color: #aa44ff; }
        .skin-rarity.legendary { color: #f7c531; }

        .skin-price {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
            font-size: 14px;
            color: #f7c531;
        }

        .skin-owned-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #44ff88;
            color: #000;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }

        .skin-equipped-badge {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #f7c531;
            color: #000;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }

        /* Quests */
        .quests-list {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .quest-card {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .quest-card.completed {
            border-color: #44ff88;
            background: rgba(68, 255, 136, 0.1);
        }

        .quest-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            background: rgba(255, 255, 255, 0.1);
        }

        .quest-info {
            flex: 1;
        }

        .quest-title {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .quest-desc {
            font-size: 13px;
            color: #888;
            margin-bottom: 10px;
        }

        .quest-progress {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
        }

        .quest-progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b35, #f7c531);
            transition: width 0.3s;
        }

        .quest-reward {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .quest-reward-amount {
            font-size: 20px;
            font-weight: bold;
            color: #f7c531;
        }

        .quest-claim-btn {
            padding: 8px 20px;
            border: none;
            border-radius: 8px;
            background: linear-gradient(45deg, #44ff88, #22cc66);
            color: #000;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .quest-claim-btn:hover {
            transform: scale(1.05);
        }

        .quest-claim-btn:disabled {
            background: #333;
            color: #666;
            cursor: not-allowed;
        }

        /* Skin Selector in Hero Card */
        .skin-selector {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 5px;
            background: rgba(0, 0, 0, 0.3);
        }

        .skin-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 2px solid #444;
            cursor: pointer;
            transition: all 0.2s;
        }

        .skin-dot:hover {
            transform: scale(1.2);
        }

        .skin-dot.active {
            border-color: #fff;
            box-shadow: 0 0 5px #fff;
        }

        .skin-dot.locked {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #44ff88;
            border-radius: 15px;
            padding: 15px 25px;
            display: flex;
            align-items: center;
            gap: 15px;
            z-index: 2000;
            animation: slideIn 0.3s, slideOut 0.3s 2.7s;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        /* Friends List */
        .btn-icon.friends { border-color: #44aaff; }

        .friends-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .friend-code-box {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #44aaff;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
        }

        .friend-code-label {
            font-size: 12px;
            color: #888;
            margin-bottom: 5px;
        }

        .friend-code {
            font-size: 24px;
            font-weight: bold;
            color: #44aaff;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .friend-code:hover {
            color: #66ccff;
            text-shadow: 0 0 10px #44aaff;
        }

        .add-friend-section {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .add-friend-section input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #333;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .add-friend-section input:focus {
            outline: none;
            border-color: #44aaff;
        }

        .add-friend-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(45deg, #44aaff, #2288dd);
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .add-friend-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(68, 170, 255, 0.4);
        }

        .friends-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .friend-card {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid #333;
            border-radius: 12px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .friend-card:hover {
            border-color: #444;
            background: rgba(0, 0, 0, 0.5);
        }

        .friend-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #44aaff, #2266aa);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            position: relative;
        }

        .friend-status-dot {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            border: 2px solid #1a1a2e;
        }

        .friend-status-dot.online { background: #44ff88; }
        .friend-status-dot.offline { background: #666; }
        .friend-status-dot.in-game { background: #f7c531; }

        .friend-info {
            flex: 1;
        }

        .friend-name {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .friend-status-text {
            font-size: 12px;
            color: #888;
        }

        .friend-status-text.online { color: #44ff88; }
        .friend-status-text.in-game { color: #f7c531; }

        .friend-actions {
            display: flex;
            gap: 8px;
        }

        .friend-action-btn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 2px solid #333;
            background: transparent;
            color: #888;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .friend-action-btn:hover {
            border-color: #44aaff;
            color: #44aaff;
        }

        .friend-action-btn.join {
            border-color: #44ff88;
            color: #44ff88;
        }

        .friend-action-btn.join:hover {
            background: rgba(68, 255, 136, 0.2);
        }

        .friend-action-btn.remove:hover {
            border-color: #ff4444;
            color: #ff4444;
        }

        .no-friends {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .no-friends-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .friend-request-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 20px;
            height: 20px;
            background: #ff4444;
            border-radius: 50%;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .menu-container {
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 25px;
            width: 100%;
            max-width: 400px;
        }

        #menu .title {
            font-size: 42px;
            margin-bottom: 5px;
        }

        #menu .subtitle {
            margin-bottom: 15px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 6px;
            color: #aaa;
            font-size: 12px;
        }

        .input-group input {
            width: 100%;
            padding: 12px;
            border: 2px solid #333;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: #fff;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        .input-group input:focus {
            outline: none;
            border-color: #ff6b35;
        }

        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #ff6b35, #f7c531);
            color: #000;
        }

        .btn-primary:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 107, 53, 0.4);
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #ff6b35;
            color: #ff6b35;
        }

        .btn-secondary:hover {
            background: rgba(255, 107, 53, 0.1);
        }

        #lobby {
            display: none;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }

        .lobby-container {
            background: rgba(20, 20, 40, 0.95);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 30px;
            width: 100%;
            max-width: 900px;
        }

        .lobby-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #333;
        }

        #heroSelect {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .room-code {
            background: rgba(255, 107, 53, 0.2);
            border: 2px solid #ff6b35;
            border-radius: 10px;
            padding: 15px 25px;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 2px;
            color: #ff6b35;
            cursor: pointer;
            transition: all 0.3s;
        }

        .room-code:hover {
            background: rgba(255, 107, 53, 0.3);
        }

        .room-code-label {
            font-size: 10px;
            color: #888;
            display: block;
            margin-bottom: 5px;
        }

        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #4ecdc4;
            color: #000;
            padding: 15px 30px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 3000;
            animation: toastIn 0.3s, toastOut 0.3s 1.7s;
        }

        @keyframes toastIn {
            from { opacity: 0; transform: translateX(-50%) translateY(20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        @keyframes toastOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .players-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 30px;
        }

        .player-slot {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #333;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
        }

        .player-slot.filled {
            border-color: #ff6b35;
            background: rgba(255, 107, 53, 0.1);
        }

        .player-slot.bot {
            border-color: #666;
            background: rgba(100, 100, 100, 0.1);
        }

        .player-slot.you {
            border-color: #4ecdc4;
            background: rgba(78, 205, 196, 0.1);
        }

        .player-avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
        }

        .player-name {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .player-status {
            font-size: 12px;
            color: #888;
        }

        .hero-selection {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #333;
        }

        .hero-selection h3 {
            margin-bottom: 20px;
            color: #f7c531;
        }

        .heroes-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 8px;
        }

        .hero-card {
            background: linear-gradient(180deg, rgba(30, 30, 50, 0.9) 0%, rgba(10, 10, 20, 0.95) 100%);
            border: 3px solid #333;
            border-radius: 15px;
            padding: 0;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            overflow: hidden;
            position: relative;
        }

        .hero-card:hover {
            transform: translateY(-5px) scale(1.02);
            border-color: #666;
        }

        .hero-card.selected {
            border-color: #ff6b35;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.5), inset 0 0 30px rgba(255, 107, 53, 0.1);
        }

        .hero-card.selected::before {
            content: '‚úì';
            position: absolute;
            top: 8px;
            right: 8px;
            background: #ff6b35;
            color: #000;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .hero-portrait {
            width: 100%;
            height: 100px;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .hero-abilities-preview {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .ability-preview {
            width: 28px;
            height: 28px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #444;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            position: relative;
            transition: all 0.2s;
        }

        .ability-preview:hover {
            border-color: #ff6b35;
            transform: scale(1.1);
        }

        .ability-preview-key {
            position: absolute;
            bottom: -8px;
            font-size: 9px;
            background: #222;
            padding: 1px 5px;
            border-radius: 3px;
            color: #ff6b35;
            font-weight: bold;
        }

        .hero-character {
            position: relative;
            width: 55px;
            height: 70px;
        }

        /* Character Head */
        .char-head {
            position: absolute;
            width: 28px;
            height: 30px;
            border-radius: 50% 50% 45% 45%;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3;
        }

        /* Character Body */
        .char-body {
            position: absolute;
            width: 36px;
            height: 28px;
            border-radius: 8px 8px 5px 5px;
            top: 28px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2;
        }

        /* Character Arms */
        .char-arms {
            position: absolute;
            width: 48px;
            height: 10px;
            border-radius: 5px;
            top: 32px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1;
        }

        /* Character Legs */
        .char-legs {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 28px;
            height: 16px;
            z-index: 2;
        }

        .char-legs::before, .char-legs::after {
            content: '';
            position: absolute;
            width: 11px;
            height: 16px;
            border-radius: 4px;
            bottom: 0;
        }

        .char-legs::before {
            left: 2px;
        }

        .char-legs::after {
            right: 2px;
        }

        /* Character Eyes */
        .char-eyes {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 17px;
            height: 6px;
            display: flex;
            justify-content: space-between;
            z-index: 4;
        }

        .char-eyes::before, .char-eyes::after {
            content: '';
            width: 6px;
            height: 6px;
            background: #fff;
            border-radius: 50%;
            box-shadow: inset 2px 0 0 #000;
        }

        /* Character Effects/Aura */
        .char-aura {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.3;
            z-index: 0;
            filter: blur(12px);
        }

        /* Hero-specific accessories */
        .char-accessory {
            position: absolute;
            z-index: 5;
        }

        .hero-info {
            padding: 8px 6px;
            background: rgba(0, 0, 0, 0.5);
        }

        .hero-name {
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 3px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hero-role {
            font-size: 9px;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hero-role.damage { color: #ff6b35; }
        .hero-role.tank { color: #ffaa44; }
        .hero-role.support { color: #44ff88; }
        .hero-role.assassin { color: #8844ff; }

        .hero-stats {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 5px;
            font-size: 9px;
            color: #666;
        }

        .hero-stat {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .hero-stat-icon {
            font-size: 12px;
        }

        #game {
            display: none;
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            display: block;
            background: #111;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .hud-left {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .health-bar-container {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 10px 15px;
            min-width: 250px;
        }

        .health-bar {
            height: 25px;
            background: #333;
            border-radius: 5px;
            overflow: hidden;
            position: relative;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff6b35);
            transition: width 0.3s;
        }

        .health-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-weight: bold;
            text-shadow: 1px 1px 2px #000;
        }

        .ability-bar {
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 10px;
        }

        .ability {
            width: 60px;
            height: 60px;
            background: #222;
            border: 2px solid #444;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .ability.ready {
            border-color: #ff6b35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.5);
        }

        .ability.cooldown {
            opacity: 0.5;
        }

        .ability-icon {
            font-size: 24px;
        }

        .ability-key {
            position: absolute;
            bottom: -8px;
            background: #333;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .ability-cooldown {
            position: absolute;
            font-size: 18px;
            font-weight: bold;
            color: #fff;
        }

        .hud-center {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 10px 20px;
        }

        .kill-goal {
            font-size: 14px;
            color: #888;
            text-align: center;
        }

        .kill-goal span {
            color: #ff6b35;
            font-weight: bold;
            font-size: 18px;
        }

        .hud-right {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 10px 15px;
            max-height: 300px;
            overflow-y: auto;
            min-width: 200px;
        }

        .scoreboard-title {
            font-size: 14px;
            color: #888;
            margin-bottom: 10px;
            text-align: center;
        }

        .scoreboard-entry {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            font-size: 12px;
        }

        .scoreboard-entry.you {
            color: #4ecdc4;
        }

        .scoreboard-entry.leading {
            color: #f7c531;
        }

        .kill-feed {
            position: absolute;
            top: 80px;
            right: 20px;
            width: 300px;
            pointer-events: none;
        }

        .kill-message {
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            margin-bottom: 5px;
            border-radius: 5px;
            font-size: 12px;
            animation: fadeIn 0.3s, fadeOut 0.3s 2.7s;
            border-left: 3px solid #ff6b35;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateX(20px); }
            to { opacity: 1; transform: translateX(0); }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        #minimap {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 200px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        #gameOver {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .winner-text {
            font-size: 48px;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .winner-text.victory {
            color: #f7c531;
        }

        .winner-text.defeat {
            color: #ff4444;
        }

        .final-stats {
            background: rgba(20, 20, 40, 0.9);
            border: 2px solid #333;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
        }

        .respawn-timer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 72px;
            font-weight: bold;
            color: #ff6b35;
            text-shadow: 0 0 30px rgba(255, 107, 53, 0.5);
            pointer-events: none;
            display: none;
        }

        .damage-indicator {
            position: absolute;
            font-size: 20px;
            font-weight: bold;
            color: #ff4444;
            pointer-events: none;
            animation: damageFloat 1s forwards;
        }

        @keyframes damageFloat {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .crosshair {
            position: absolute;
            pointer-events: none;
            width: 20px;
            height: 20px;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.8);
        }

        .crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }

        .crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }

        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .loading.active {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #333;
            border-top-color: #ff6b35;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .controls-help {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 10px;
            padding: 15px;
            font-size: 12px;
        }

        .controls-help div {
            margin-bottom: 5px;
        }

        .controls-help span {
            color: #ff6b35;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Server Status -->
    <div class="server-status" id="serverStatus">
        <div class="server-status-dot" id="serverStatusDot"></div>
        <span id="serverStatusText">Connecting...</span>
    </div>

    <!-- Currency Display -->
    <div class="currency-display" id="currencyDisplay" style="display: none;">
        <span class="currency-icon">üíé</span>
        <span class="currency-amount" id="currencyAmount">0</span>
    </div>

    <!-- Login Screen -->
    <div id="loginScreen">
        <h1 class="title">ICONX</h1>
        <p class="subtitle">HERO ARENA</p>
        <div class="login-container">
            <div class="login-tabs">
                <button class="login-tab active" onclick="switchLoginTab('guest')">Quick Play</button>
                <button class="login-tab" onclick="switchLoginTab('login')">Login</button>
                <button class="login-tab" onclick="switchLoginTab('register')">Register</button>
            </div>

            <div id="guestForm" class="login-form active">
                <div class="input-group">
                    <label>Display Name</label>
                    <input type="text" id="guestName" placeholder="Enter your name" maxlength="20">
                </div>
                <button class="btn btn-primary" onclick="guestLogin()">PLAY AS GUEST</button>
                <p style="text-align: center; color: #666; margin-top: 15px; font-size: 12px;">
                    Guest progress is saved locally. Create an account to sync across devices!
                </p>
            </div>

            <div id="loginForm" class="login-form">
                <div class="input-group">
                    <label>Username</label>
                    <input type="text" id="loginUsername" placeholder="Enter username">
                </div>
                <div class="input-group">
                    <label>Password</label>
                    <input type="password" id="loginPassword" placeholder="Enter password">
                </div>
                <button class="btn btn-primary" onclick="login()">LOGIN</button>
            </div>

            <div id="registerForm" class="login-form">
                <div class="input-group">
                    <label>Username</label>
                    <input type="text" id="registerUsername" placeholder="Choose a username" maxlength="20">
                </div>
                <div class="input-group">
                    <label>Password</label>
                    <input type="password" id="registerPassword" placeholder="Create a password" minlength="6">
                </div>
                <div class="input-group">
                    <label>Confirm Password</label>
                    <input type="password" id="registerConfirmPassword" placeholder="Confirm password">
                </div>
                <button class="btn btn-primary" onclick="register()">CREATE ACCOUNT</button>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="menu" style="display: none;">
        <h1 class="title">ICONX</h1>
        <p class="subtitle">HERO ARENA</p>
        <div class="menu-container">
            <div class="input-group">
                <label>PLAYER NAME</label>
                <input type="text" id="playerName" placeholder="Enter your name..." maxlength="16" autocomplete="off">
            </div>
            <button class="btn btn-primary" onclick="findMatch()">FIND MATCH</button>
            <button class="btn btn-secondary" onclick="quickPlay()" style="margin-top: 10px; background: rgba(78, 205, 196, 0.2); border-color: #4ecdc4; color: #4ecdc4;">QUICK PLAY (vs Bots)</button>

            <!-- Shop & Quests Buttons -->
            <div class="menu-buttons-row">
                <div class="btn-icon shop" onclick="openShop()" title="Shop">üõí</div>
                <div class="btn-icon quests" onclick="openQuests()" title="Quests">üìã</div>
                <div class="btn-icon skins" onclick="openSkins()" title="My Skins">üë§</div>
                <div class="btn-icon friends" onclick="openFriends()" title="Friends" style="position: relative;">
                    üë•
                    <span class="friend-request-badge" id="friendRequestBadge" style="display: none;">0</span>
                </div>
            </div>

            <div style="border-top: 1px solid #333; padding-top: 20px; margin-top: 15px;">
                <p style="color: #888; font-size: 12px; margin-bottom: 15px;">PRIVATE ROOMS - PLAY WITH FRIENDS</p>
                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <button class="btn btn-secondary" onclick="createPrivateRoom()" style="flex: 1; background: rgba(255, 170, 68, 0.2); border-color: #ffaa44; color: #ffaa44; margin: 0;">CREATE ROOM</button>
                </div>
                <div class="input-group" style="margin-bottom: 10px;">
                    <label>JOIN A ROOM</label>
                    <input type="text" id="roomCode" placeholder="Enter room code..." maxlength="8" autocomplete="off" style="text-transform: uppercase;">
                </div>
                <button class="btn btn-secondary" onclick="joinPrivateRoom()" style="background: rgba(170, 68, 255, 0.2); border-color: #aa44ff; color: #aa44ff;">JOIN ROOM</button>
            </div>
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="modal" id="shopModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title"><span>üõí</span> SHOP</div>
                <button class="modal-close" onclick="closeShop()">√ó</button>
            </div>
            <div class="shop-tabs">
                <button class="shop-tab active" onclick="switchShopTab('blaze')">üî• Blaze</button>
                <button class="shop-tab" onclick="switchShopTab('frost')">‚ùÑÔ∏è Frost</button>
                <button class="shop-tab" onclick="switchShopTab('shadow')">üë§ Shadow</button>
                <button class="shop-tab" onclick="switchShopTab('titan')">üõ°Ô∏è Titan</button>
                <button class="shop-tab" onclick="switchShopTab('healer')">üíö Sage</button>
                <button class="shop-tab" onclick="switchShopTab('sniper')">üéØ Hawk</button>
            </div>
            <div class="skins-grid" id="shopSkinsGrid"></div>
        </div>
    </div>

    <!-- Quests Modal -->
    <div class="modal" id="questsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title"><span>üìã</span> QUESTS</div>
                <button class="modal-close" onclick="closeQuests()">√ó</button>
            </div>
            <div class="quests-list" id="questsList"></div>
        </div>
    </div>

    <!-- Skins Collection Modal -->
    <div class="modal" id="skinsModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title"><span>üë§</span> MY COLLECTION</div>
                <button class="modal-close" onclick="closeSkins()">√ó</button>
            </div>
            <div class="shop-tabs" id="collectionTabs"></div>
            <div class="skins-grid" id="collectionGrid"></div>
        </div>
    </div>

    <!-- Friends Modal -->
    <div class="modal" id="friendsModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header">
                <div class="modal-title"><span>üë•</span> FRIENDS</div>
                <button class="modal-close" onclick="closeFriends()">√ó</button>
            </div>

            <!-- Your Friend Code -->
            <div class="friend-code-box">
                <div class="friend-code-label">YOUR FRIEND CODE (Click to copy)</div>
                <div class="friend-code" id="myFriendCode" onclick="copyFriendCode()">LOADING...</div>
            </div>

            <!-- Add Friend -->
            <div class="add-friend-section">
                <input type="text" id="addFriendInput" placeholder="Enter friend code..." maxlength="12" autocomplete="off">
                <button class="add-friend-btn" onclick="addFriend()">ADD</button>
            </div>

            <!-- Friends List -->
            <div class="friends-list" id="friendsList">
                <div class="no-friends">
                    <div class="no-friends-icon">üë•</div>
                    <div>No friends yet</div>
                    <div style="font-size: 12px; margin-top: 5px;">Share your friend code to connect!</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hero Selection (Quick Play) -->
    <div id="heroSelect">
        <div class="lobby-container" style="max-width: 700px; margin: 15px auto; padding: 20px;">
            <h2 style="text-align: center; margin-bottom: 8px; color: #f7c531; font-size: 24px; letter-spacing: 3px;">SELECT YOUR HERO</h2>
            <p style="text-align: center; color: #666; margin-bottom: 15px; font-size: 13px;">Choose your champion and enter the arena</p>
            <div class="heroes-grid" id="quickPlayHeroesGrid" style="grid-template-columns: repeat(3, 1fr); gap: 12px;"></div>
            <div style="text-align: center; margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
                <button class="btn btn-secondary" onclick="cancelQuickPlay()" style="max-width: 150px; padding: 10px;">BACK</button>
                <button class="btn btn-primary" onclick="startQuickPlayGame()" style="max-width: 200px; padding: 10px;">START MATCH</button>
            </div>
        </div>
    </div>

    <!-- Lobby -->
    <div id="lobby">
        <div class="lobby-container">
            <div class="lobby-header">
                <h2>MATCH LOBBY</h2>
                <div style="display: flex; gap: 15px; align-items: center;">
                    <div class="room-code" id="displayRoomCode" onclick="copyRoomCode()" title="Click to copy">
                        <span class="room-code-label">CLICK TO COPY ROOM CODE</span>
                        <span id="roomCodeText">XXXX</span>
                    </div>
                    <button onclick="openFriends()" style="padding: 15px 20px; border: 2px solid #44aaff; border-radius: 10px; background: rgba(68, 170, 255, 0.1); color: #44aaff; font-size: 16px; cursor: pointer; transition: all 0.3s;" onmouseover="this.style.background='rgba(68, 170, 255, 0.2)'" onmouseout="this.style.background='rgba(68, 170, 255, 0.1)'">
                        üë• Invite Friends
                    </button>
                </div>
            </div>
            <div class="players-grid" id="playersGrid"></div>
            <div class="hero-selection">
                <h3>SELECT YOUR HERO</h3>
                <div class="heroes-grid" id="heroesGrid"></div>
            </div>
            <div id="lobbyStatus" style="text-align: center; margin-top: 20px; color: #888;">
                <span id="playerCount">1</span>/10 Players ‚Ä¢ <span id="waitingText">Waiting for players...</span>
            </div>
            <div id="autoStartContainer" style="text-align: center; margin-top: 15px;">
                <div style="background: rgba(255, 107, 53, 0.2); border: 2px solid #ff6b35; border-radius: 10px; padding: 15px; display: inline-block;">
                    <span style="color: #f7c531;">Auto-starting in </span>
                    <span id="autoStartCountdown" style="color: #ff6b35; font-size: 24px; font-weight: bold;">15</span>
                    <span style="color: #f7c531;"> seconds</span>
                    <p style="color: #888; font-size: 12px; margin-top: 5px;">Empty slots will be filled with bots</p>
                </div>
            </div>
            <button class="btn btn-primary" id="startBtn" onclick="startGame()" style="margin-top: 20px;">START NOW</button>
            <button class="btn btn-secondary" onclick="leaveLobby()" style="margin-top: 10px;">LEAVE LOBBY</button>
        </div>
    </div>

    <!-- Game -->
    <div id="game">
        <canvas id="gameCanvas"></canvas>
        <div id="hud">
            <button onclick="leaveGame()" style="position: absolute; top: 20px; left: 20px; padding: 8px 15px; background: rgba(255, 68, 68, 0.8); border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; z-index: 100;">LEAVE GAME</button>
            <div class="hud-left">
                <div class="health-bar-container">
                    <div class="health-bar">
                        <div class="health-fill" id="healthFill" style="width: 100%"></div>
                        <span class="health-text" id="healthText">100/100</span>
                    </div>
                </div>
                <div class="ability-bar" id="abilityBar"></div>
            </div>
            <div class="hud-center">
                <div class="kill-goal">FIRST TO <span>50</span> KILLS</div>
            </div>
            <div class="hud-right">
                <div class="scoreboard-title">SCOREBOARD</div>
                <div id="scoreboard"></div>
            </div>
        </div>
        <div class="kill-feed" id="killFeed"></div>
        <div id="minimap">
            <canvas id="minimapCanvas"></canvas>
        </div>
        <div class="respawn-timer" id="respawnTimer"></div>
        <div class="controls-help">
            <div><span>WASD</span> - Move</div>
            <div><span>MOUSE</span> - Aim</div>
            <div><span>CLICK</span> - Attack</div>
            <div><span>Q/E/R</span> - Abilities</div>
            <div><span>SHIFT</span> - Dash</div>
        </div>
    </div>

    <!-- Game Over -->
    <div id="gameOver">
        <div class="winner-text" id="winnerText">VICTORY!</div>
        <div class="final-stats" id="finalStats"></div>
        <button class="btn btn-primary" onclick="returnToMenu()">RETURN TO MENU</button>
    </div>

    <!-- Loading Screen -->
    <div class="loading" id="loading">
        <div class="spinner"></div>
        <div id="loadingText">Connecting...</div>
    </div>

    <script>
        // ========================================
        // CLOUD SERVER CONNECTION
        // ========================================
        const SERVER_URL = window.location.hostname === 'localhost'
            ? 'ws://localhost:3000'
            : `wss://${window.location.host}`;

        let ws = null;
        let isConnected = false;
        let playerId = null;
        let myFriendCode = null;
        let isLoggedIn = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        function connectToServer() {
            updateServerStatus('connecting');

            try {
                ws = new WebSocket(SERVER_URL);
            } catch (e) {
                updateServerStatus('disconnected');
                return;
            }

            ws.onopen = () => {
                console.log('Connected to server');
                isConnected = true;
                reconnectAttempts = 0;
                updateServerStatus('connected');

                // Sync with server if already logged in locally
                if (isLoggedIn) {
                    const savedAuth = localStorage.getItem('iconx_auth');
                    if (savedAuth) {
                        const auth = JSON.parse(savedAuth);
                        ws.send(JSON.stringify({
                            type: 'login',
                            username: auth.username,
                            password: auth.password
                        }));
                    }
                }
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleServerMessage(data);
                } catch (e) {
                    console.error('Failed to parse server message:', e);
                }
            };

            ws.onclose = () => {
                console.log('Disconnected from server');
                isConnected = false;
                updateServerStatus('disconnected');

                // Try to reconnect
                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    reconnectAttempts++;
                    setTimeout(() => connectToServer(), 2000 * reconnectAttempts);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateServerStatus('disconnected');
            };
        }

        function updateServerStatus(status) {
            const dot = document.getElementById('serverStatusDot');
            const text = document.getElementById('serverStatusText');

            dot.className = 'server-status-dot';

            switch (status) {
                case 'connected':
                    dot.classList.add('connected');
                    text.textContent = 'Connected';
                    break;
                case 'connecting':
                    dot.classList.add('connecting');
                    text.textContent = 'Connecting...';
                    break;
                case 'disconnected':
                    text.textContent = 'Disconnected';
                    break;
            }
        }

        function sendToServer(data) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(data));
            }
        }

        // ========================================
        // AUTH FUNCTIONS (Local Storage)
        // ========================================
        function getLocalAccounts() {
            const accounts = localStorage.getItem('iconx_accounts');
            return accounts ? JSON.parse(accounts) : {};
        }

        function saveLocalAccounts(accounts) {
            localStorage.setItem('iconx_accounts', JSON.stringify(accounts));
        }

        function generateLocalFriendCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 8; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function switchLoginTab(tab) {
            document.querySelectorAll('.login-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.login-form').forEach(f => f.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tab + 'Form').classList.add('active');
        }

        function guestLogin() {
            const name = document.getElementById('guestName').value.trim() || 'Guest' + Math.floor(Math.random() * 10000);

            // Generate local player data
            playerId = 'local_' + Math.random().toString(36).substr(2, 9);
            myFriendCode = generateLocalFriendCode();
            playerName = name;
            isLoggedIn = true;

            // Create guest player data
            playerData = {
                username: name,
                currency: 500,
                ownedSkins: {},
                equippedSkins: {},
                stats: { totalKills: 0, totalDeaths: 0, matchesPlayed: 0, wins: 0 },
                friends: []
            };

            // Sync with server if connected
            if (isConnected) {
                sendToServer({
                    type: 'guestLogin',
                    username: name
                });
            }

            showMainMenu();
        }

        function login() {
            const username = document.getElementById('loginUsername').value.trim();
            const password = document.getElementById('loginPassword').value;

            if (!username || !password) {
                showNotification('Please enter username and password', '#ff4444');
                return;
            }

            // Check local accounts
            const accounts = getLocalAccounts();
            const account = Object.values(accounts).find(
                acc => acc.username.toLowerCase() === username.toLowerCase() && acc.password === password
            );

            if (!account) {
                showNotification('Invalid username or password', '#ff4444');
                return;
            }

            // Login successful
            playerId = 'local_' + Math.random().toString(36).substr(2, 9);
            myFriendCode = account.friendCode;
            playerName = account.username;
            isLoggedIn = true;
            playerData = { ...account.playerData };

            // Save for auto-login
            localStorage.setItem('iconx_auth', JSON.stringify({ username, password }));

            // Sync with server if connected
            if (isConnected) {
                sendToServer({
                    type: 'login',
                    username: username,
                    password: password
                });
            }

            showMainMenu();
        }

        function register() {
            const username = document.getElementById('registerUsername').value.trim();
            const password = document.getElementById('registerPassword').value;
            const confirmPassword = document.getElementById('registerConfirmPassword').value;

            if (!username || !password) {
                showNotification('Please fill in all fields', '#ff4444');
                return;
            }

            if (password !== confirmPassword) {
                showNotification('Passwords do not match', '#ff4444');
                return;
            }

            if (password.length < 6) {
                showNotification('Password must be at least 6 characters', '#ff4444');
                return;
            }

            // Check if username exists locally
            const accounts = getLocalAccounts();
            const exists = Object.values(accounts).some(
                acc => acc.username.toLowerCase() === username.toLowerCase()
            );

            if (exists) {
                showNotification('Username already exists', '#ff4444');
                return;
            }

            // Create new account locally
            const friendCode = generateLocalFriendCode();
            const newPlayerData = {
                username: username,
                currency: 500,
                ownedSkins: {},
                equippedSkins: {},
                stats: { totalKills: 0, totalDeaths: 0, matchesPlayed: 0, wins: 0 },
                friends: []
            };

            accounts[friendCode] = {
                username: username,
                password: password,
                friendCode: friendCode,
                playerData: newPlayerData
            };
            saveLocalAccounts(accounts);

            // Login with new account
            playerId = 'local_' + Math.random().toString(36).substr(2, 9);
            myFriendCode = friendCode;
            playerName = username;
            isLoggedIn = true;
            playerData = { ...newPlayerData };

            // Save for auto-login
            localStorage.setItem('iconx_auth', JSON.stringify({ username, password }));

            // Sync with server if connected
            if (isConnected) {
                sendToServer({
                    type: 'register',
                    username: username,
                    password: password
                });
            }

            showNotification('Account created successfully!', '#44ff88');
            showMainMenu();
        }

        function tryAutoLogin() {
            const savedAuth = localStorage.getItem('iconx_auth');
            if (!savedAuth) return;

            try {
                const auth = JSON.parse(savedAuth);
                const accounts = getLocalAccounts();
                const account = Object.values(accounts).find(
                    acc => acc.username.toLowerCase() === auth.username.toLowerCase() && acc.password === auth.password
                );

                if (account) {
                    // Auto-login successful
                    playerId = 'local_' + Math.random().toString(36).substr(2, 9);
                    myFriendCode = account.friendCode;
                    playerName = account.username;
                    isLoggedIn = true;
                    playerData = { ...account.playerData };

                    showMainMenu();
                }
            } catch (e) {
                console.error('Auto-login failed:', e);
            }
        }

        function handleServerMessage(data) {
            switch (data.type) {
                case 'connected':
                    playerId = data.playerId;
                    break;

                case 'loginResult':
                case 'registerResult':
                    if (data.success) {
                        // Sync server playerId for online features
                        playerId = data.playerId;
                        if (data.friendCode) myFriendCode = data.friendCode;

                        // Sync player data from server if available
                        if (data.playerData) {
                            playerData = { ...playerData, ...data.playerData };
                        }

                        console.log('Synced with server:', playerId);
                    }
                    // Don't show error - local login already handled it
                    break;

                case 'matchmakingStatus':
                    if (data.status === 'searching') {
                        updateLoadingText(`Searching for match... (${data.playersInQueue} in queue)`);
                    } else if (data.status === 'cancelled') {
                        hideLoading();
                    }
                    break;

                case 'matchFound':
                    hideLoading();
                    currentMap = data.map;
                    roomId = data.gameId;
                    showNotification('Match found!', '#44ff88');
                    // Game will start when server sends gameState
                    break;

                case 'roomCreated':
                    hideLoading();
                    roomId = data.roomCode;
                    document.getElementById('heroSelect').style.display = 'none';
                    showLobbyWithCode(data.roomCode);
                    showNotification('Room created! Share the code with friends.', '#44ff88');
                    break;

                case 'roomJoined':
                    hideLoading();
                    roomId = data.roomCode;
                    document.getElementById('heroSelect').style.display = 'none';
                    showLobbyWithCode(data.roomCode);
                    showNotification('Joined room!', '#44ff88');
                    break;

                case 'roomError':
                    hideLoading();
                    document.getElementById('heroSelect').style.display = 'none';
                    document.getElementById('menu').style.display = 'flex';
                    showNotification(data.error, '#ff4444');
                    break;

                case 'roomUpdate':
                    updateRoomLobby(data);
                    break;

                case 'gameState':
                    handleGameStateUpdate(data);
                    break;

                case 'kill':
                    addKillFeedMessage(data.killerName, data.victimName);
                    break;

                case 'ability':
                    // Handle ability visual effects
                    break;

                case 'gameEnd':
                    handleGameEnd(data);
                    break;

                case 'leftGame':
                    returnToMenu();
                    break;

                case 'friendsList':
                    handleFriendsList(data.friends);
                    break;

                case 'friendResult':
                    if (data.success) {
                        showNotification(`Added ${data.friend.username} as friend!`, '#44ff88');
                        sendToServer({ type: 'getFriendsList' });
                    } else {
                        showNotification(data.error, '#ff4444');
                    }
                    break;

                case 'friendStatusUpdate':
                    // Update friend's online status
                    friendsOnlineStatus[data.friendCode] = {
                        online: data.status !== 'offline',
                        inGame: data.status === 'in-game',
                        status: data.status
                    };
                    if (document.getElementById('friendsModal').classList.contains('active')) {
                        renderFriendsList();
                    }
                    break;

                case 'playerData':
                    playerData = { ...playerData, ...data.playerData };
                    myFriendCode = data.friendCode;
                    updateCurrencyDisplay();
                    break;

                case 'playerDataUpdated':
                    // Confirmation that data was saved
                    break;
            }
        }

        function showMainMenu() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('currencyDisplay').style.display = 'flex';

            // Update displays
            updateCurrencyDisplay();
            document.getElementById('playerName').value = playerName;

            // Update friend code display
            const friendCodeEl = document.getElementById('myFriendCode');
            if (friendCodeEl) {
                friendCodeEl.textContent = myFriendCode;
            }

            // Initialize hero selection
            renderHeroSelection();
        }

        function handleGameStateUpdate(data) {
            if (!gameState || gameState.status !== 'playing') {
                // Initialize game
                gameState = {
                    status: 'playing',
                    players: [],
                    projectiles: [],
                    areas: [],
                    traps: []
                };

                // Start gameplay
                document.getElementById('menu').style.display = 'none';
                document.getElementById('heroSelect').style.display = 'none';
                startGameplay();
            }

            // Update players
            const allEntities = [...data.players, ...data.bots];
            gameState.players = allEntities.map(p => {
                const existing = gameState.players.find(ep => ep.id === p.id);
                const hero = HEROES.find(h => h.id === p.heroId) || HEROES[0];

                return {
                    id: p.id,
                    peerId: p.id,
                    name: p.username,
                    heroId: p.heroId,
                    x: p.x,
                    y: p.y,
                    angle: Math.atan2(p.direction?.y || 0, p.direction?.x || 1),
                    health: p.health,
                    maxHealth: p.maxHealth,
                    kills: p.kills,
                    deaths: p.deaths,
                    alive: p.health > 0,
                    isBot: p.isBot,
                    effects: existing?.effects || [],
                    shielded: false,
                    invisible: false,
                    input: existing?.input || { up: false, down: false, left: false, right: false, attack: false, abilities: [false, false, false], dash: false, angle: 0 }
                };
            });

            // Update projectiles
            gameState.projectiles = data.projectiles.map(p => ({
                x: p.x,
                y: p.y,
                color: HEROES.find(h => h.id === p.heroId)?.color || '#fff',
                isAbility: p.isAbility
            }));

            // Update health packs
            if (currentMap) {
                currentMap.healthPacks = data.healthPacks;
            }

            // Update kill scores for leaderboard
            gameState.killScores = data.killScores;
        }

        function handleGameEnd(data) {
            const winner = gameState.players.find(p => p.id === data.winnerId);
            const me = gameState.players.find(p => p.id === playerId);

            if (me) {
                const won = me.id === data.winnerId;
                updateMatchStats(me.kills, me.deaths, won, selectedHero.id);
            }

            endGame(winner || { name: data.winnerName });
        }

        // ========================================
        // GAME CONFIGURATION
        // ========================================
        const CONFIG = {
            MAX_PLAYERS: 10,
            KILL_GOAL: 50,
            RESPAWN_TIME: 3,
            MAP_WIDTH: 3000,
            MAP_HEIGHT: 2000,
            TICK_RATE: 60
        };

        // ========================================
        // HEROES DEFINITION
        // ========================================
        const HEROES = [
            {
                id: 'blaze',
                name: 'Blaze',
                role: 'Damage',
                icon: 'üî•',
                color: '#ff4444',
                health: 200,
                speed: 5,
                attackDamage: 25,
                attackRange: 400,
                attackSpeed: 0.4,
                projectileSpeed: 15,
                abilities: [
                    { name: 'Fireball', key: 'Q', cooldown: 5, damage: 60, icon: 'üî•', type: 'projectile', speed: 20, range: 600 },
                    { name: 'Flame Wall', key: 'E', cooldown: 10, damage: 30, icon: 'üß±', type: 'area', duration: 3 },
                    { name: 'Inferno', key: 'R', cooldown: 25, damage: 100, icon: 'üí•', type: 'ultimate', radius: 200 }
                ]
            },
            {
                id: 'frost',
                name: 'Frost',
                role: 'Damage',
                icon: '‚ùÑÔ∏è',
                color: '#44aaff',
                health: 180,
                speed: 5.5,
                attackDamage: 22,
                attackRange: 450,
                attackSpeed: 0.35,
                projectileSpeed: 18,
                abilities: [
                    { name: 'Ice Shard', key: 'Q', cooldown: 4, damage: 50, icon: 'üßä', type: 'projectile', speed: 25, range: 500 },
                    { name: 'Freeze', key: 'E', cooldown: 12, damage: 20, icon: 'ü•∂', type: 'cc', duration: 2 },
                    { name: 'Blizzard', key: 'R', cooldown: 30, damage: 80, icon: 'üå®Ô∏è', type: 'ultimate', radius: 250 }
                ]
            },
            {
                id: 'shadow',
                name: 'Shadow',
                role: 'Assassin',
                icon: 'üë§',
                color: '#8844ff',
                health: 150,
                speed: 7,
                attackDamage: 35,
                attackRange: 150,
                attackSpeed: 0.25,
                projectileSpeed: 0,
                abilities: [
                    { name: 'Blink', key: 'Q', cooldown: 6, damage: 0, icon: 'üí®', type: 'teleport', range: 300 },
                    { name: 'Backstab', key: 'E', cooldown: 8, damage: 80, icon: 'üó°Ô∏è', type: 'melee', range: 100 },
                    { name: 'Shadow Form', key: 'R', cooldown: 20, damage: 0, icon: 'üëª', type: 'ultimate', duration: 5 }
                ]
            },
            {
                id: 'titan',
                name: 'Titan',
                role: 'Tank',
                icon: 'üõ°Ô∏è',
                color: '#ffaa44',
                health: 400,
                speed: 3.5,
                attackDamage: 40,
                attackRange: 120,
                attackSpeed: 0.6,
                projectileSpeed: 0,
                abilities: [
                    { name: 'Charge', key: 'Q', cooldown: 8, damage: 50, icon: 'üêÇ', type: 'dash', range: 400 },
                    { name: 'Shield', key: 'E', cooldown: 15, damage: 0, icon: 'üõ°Ô∏è', type: 'buff', duration: 3 },
                    { name: 'Earthquake', key: 'R', cooldown: 25, damage: 120, icon: 'üí¢', type: 'ultimate', radius: 300 }
                ]
            },
            {
                id: 'healer',
                name: 'Sage',
                role: 'Support',
                icon: 'üíö',
                color: '#44ff88',
                health: 175,
                speed: 5,
                attackDamage: 18,
                attackRange: 350,
                attackSpeed: 0.4,
                projectileSpeed: 12,
                abilities: [
                    { name: 'Heal Burst', key: 'Q', cooldown: 6, damage: -50, icon: 'üíñ', type: 'heal', radius: 150 },
                    { name: 'Shield Ally', key: 'E', cooldown: 10, damage: 0, icon: '‚ú®', type: 'buff', duration: 4 },
                    { name: 'Revive Zone', key: 'R', cooldown: 30, damage: -100, icon: 'üåü', type: 'ultimate', radius: 200 }
                ]
            },
            {
                id: 'sniper',
                name: 'Hawk',
                role: 'Damage',
                icon: 'üéØ',
                color: '#ff44aa',
                health: 150,
                speed: 4.5,
                attackDamage: 45,
                attackRange: 700,
                attackSpeed: 0.8,
                projectileSpeed: 30,
                abilities: [
                    { name: 'Piercing Shot', key: 'Q', cooldown: 7, damage: 80, icon: 'üí´', type: 'projectile', speed: 40, range: 1000 },
                    { name: 'Trap', key: 'E', cooldown: 12, damage: 30, icon: 'ü™§', type: 'trap', duration: 15 },
                    { name: 'Headshot', key: 'R', cooldown: 20, damage: 150, icon: '‚ò†Ô∏è', type: 'ultimate', range: 800 }
                ]
            }
        ];

        // ========================================
        // MAP THEMES
        // ========================================
        const MAP_THEMES = [
            {
                name: 'Industrial',
                bgColor: '#1a1a2e',
                wallColor: '#4a4a6e',
                accentColor: '#ff6b35',
                obstacles: 'boxes'
            },
            {
                name: 'Nature',
                bgColor: '#1a2e1a',
                wallColor: '#2e4a2e',
                accentColor: '#44ff88',
                obstacles: 'trees'
            },
            {
                name: 'Tech',
                bgColor: '#1a1a3e',
                wallColor: '#3e3e6e',
                accentColor: '#44aaff',
                obstacles: 'servers'
            },
            {
                name: 'Lava',
                bgColor: '#2e1a1a',
                wallColor: '#4a2a2a',
                accentColor: '#ff4444',
                obstacles: 'rocks'
            },
            {
                name: 'Ice',
                bgColor: '#1a2a3e',
                wallColor: '#3e5a7e',
                accentColor: '#88ddff',
                obstacles: 'crystals'
            }
        ];

        // ========================================
        // SKINS SYSTEM
        // ========================================
        const SKINS = {
            blaze: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#ff6644', body: '#cc3311', arms: '#aa2200', legs: '#881100', aura: '#ff4400' } },
                { id: 'inferno', name: 'Inferno', rarity: 'rare', price: 500, colors: { head: '#ff8800', body: '#ff5500', arms: '#cc4400', legs: '#aa3300', aura: '#ff6600' } },
                { id: 'phoenix', name: 'Phoenix', rarity: 'epic', price: 1200, colors: { head: '#ffcc00', body: '#ff9900', arms: '#ff6600', legs: '#cc5500', aura: '#ffaa00' } },
                { id: 'darkflame', name: 'Dark Flame', rarity: 'legendary', price: 2500, colors: { head: '#8844ff', body: '#6622cc', arms: '#441199', legs: '#330077', aura: '#9955ff' } }
            ],
            frost: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#66bbff', body: '#3399dd', arms: '#2277bb', legs: '#1155aa', aura: '#44aaff' } },
                { id: 'glacier', name: 'Glacier', rarity: 'rare', price: 500, colors: { head: '#aaddff', body: '#77bbee', arms: '#5599cc', legs: '#3377aa', aura: '#88ccff' } },
                { id: 'arctic', name: 'Arctic', rarity: 'epic', price: 1200, colors: { head: '#ffffff', body: '#ddeeff', arms: '#bbddff', legs: '#99ccff', aura: '#eeffff' } },
                { id: 'abyssal', name: 'Abyssal Ice', rarity: 'legendary', price: 2500, colors: { head: '#2244aa', body: '#113388', arms: '#002266', legs: '#001144', aura: '#3355cc' } }
            ],
            shadow: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#6633aa', body: '#442288', arms: '#331166', legs: '#220044', aura: '#8844ff' } },
                { id: 'phantom', name: 'Phantom', rarity: 'rare', price: 500, colors: { head: '#555555', body: '#333333', arms: '#222222', legs: '#111111', aura: '#666666' } },
                { id: 'void', name: 'Void Walker', rarity: 'epic', price: 1200, colors: { head: '#220033', body: '#110022', arms: '#0a0015', legs: '#050008', aura: '#330044' } },
                { id: 'neon', name: 'Neon Shadow', rarity: 'legendary', price: 2500, colors: { head: '#ff00ff', body: '#cc00cc', arms: '#9900aa', legs: '#660088', aura: '#ff44ff' } }
            ],
            titan: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#ddaa44', body: '#bb8822', arms: '#996600', legs: '#774400', aura: '#ffaa44' } },
                { id: 'iron', name: 'Iron Guard', rarity: 'rare', price: 500, colors: { head: '#888888', body: '#666666', arms: '#555555', legs: '#444444', aura: '#999999' } },
                { id: 'golden', name: 'Golden Titan', rarity: 'epic', price: 1200, colors: { head: '#ffdd00', body: '#ddbb00', arms: '#bb9900', legs: '#997700', aura: '#ffee44' } },
                { id: 'obsidian', name: 'Obsidian', rarity: 'legendary', price: 2500, colors: { head: '#2a2a35', body: '#1a1a25', arms: '#151520', legs: '#101015', aura: '#3a3a45' } }
            ],
            healer: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#44dd88', body: '#22bb66', arms: '#119944', legs: '#007722', aura: '#44ff88' } },
                { id: 'nature', name: 'Nature', rarity: 'rare', price: 500, colors: { head: '#88cc44', body: '#66aa22', arms: '#448811', legs: '#336600', aura: '#99dd55' } },
                { id: 'divine', name: 'Divine', rarity: 'epic', price: 1200, colors: { head: '#ffffaa', body: '#ffff77', arms: '#eeee55', legs: '#dddd33', aura: '#ffffcc' } },
                { id: 'corrupted', name: 'Corrupted', rarity: 'legendary', price: 2500, colors: { head: '#aa2255', body: '#881144', arms: '#660033', legs: '#440022', aura: '#cc3366' } }
            ],
            sniper: [
                { id: 'default', name: 'Default', rarity: 'common', price: 0, colors: { head: '#dd4488', body: '#aa2266', arms: '#881144', legs: '#660022', aura: '#ff44aa' } },
                { id: 'tactical', name: 'Tactical', rarity: 'rare', price: 500, colors: { head: '#446644', body: '#335533', arms: '#224422', legs: '#113311', aura: '#557755' } },
                { id: 'cyber', name: 'Cyber', rarity: 'epic', price: 1200, colors: { head: '#00ffff', body: '#00cccc', arms: '#009999', legs: '#006666', aura: '#44ffff' } },
                { id: 'assassin', name: 'Elite Assassin', rarity: 'legendary', price: 2500, colors: { head: '#cc0000', body: '#990000', arms: '#660000', legs: '#440000', aura: '#ff2222' } }
            ]
        };

        // Quests definition
        const QUESTS = [
            { id: 'first_blood', title: 'First Blood', desc: 'Get your first kill', icon: 'üó°Ô∏è', goal: 1, reward: 100, type: 'kills' },
            { id: 'warrior', title: 'Warrior', desc: 'Get 10 kills total', icon: '‚öîÔ∏è', goal: 10, reward: 250, type: 'kills' },
            { id: 'slayer', title: 'Slayer', desc: 'Get 50 kills total', icon: 'üíÄ', goal: 50, reward: 750, type: 'kills' },
            { id: 'legend', title: 'Legend', desc: 'Get 100 kills total', icon: 'üëë', goal: 100, reward: 1500, type: 'kills' },
            { id: 'survivor', title: 'Survivor', desc: 'Play 5 matches', icon: 'üéÆ', goal: 5, reward: 300, type: 'matches' },
            { id: 'veteran', title: 'Veteran', desc: 'Play 20 matches', icon: 'üéñÔ∏è', goal: 20, reward: 800, type: 'matches' },
            { id: 'winner', title: 'Winner', desc: 'Win a match', icon: 'üèÜ', goal: 1, reward: 500, type: 'wins' },
            { id: 'champion', title: 'Champion', desc: 'Win 5 matches', icon: 'ü•á', goal: 5, reward: 1200, type: 'wins' },
            { id: 'healer_quest', title: 'Medic', desc: 'Heal 500 HP total', icon: 'üíö', goal: 500, reward: 400, type: 'healing' },
            { id: 'explorer', title: 'Explorer', desc: 'Try all 6 heroes', icon: 'üîç', goal: 6, reward: 600, type: 'heroes_played' }
        ];

        // Player data (saved to localStorage)
        let playerData = {
            currency: 500, // Start with 500 gems
            ownedSkins: {
                blaze: ['default'],
                frost: ['default'],
                shadow: ['default'],
                titan: ['default'],
                healer: ['default'],
                sniper: ['default']
            },
            equippedSkins: {
                blaze: 'default',
                frost: 'default',
                shadow: 'default',
                titan: 'default',
                healer: 'default',
                sniper: 'default'
            },
            questProgress: {},
            claimedQuests: [],
            stats: {
                totalKills: 0,
                totalDeaths: 0,
                matchesPlayed: 0,
                wins: 0,
                healingDone: 0,
                heroesPlayed: []
            },
            friends: []
        };

        let currentShopHero = 'blaze';
        let currentCollectionHero = 'blaze';

        // ========================================
        // GAME STATE
        // ========================================
        let peer = null;
        let connections = [];
        let isHost = false;
        let myId = null;
        let roomId = null;
        let playerName = 'Player';
        let selectedHero = HEROES[0];
        let gameState = null;
        let localPlayer = null;
        let canvas, ctx, minimapCanvas, minimapCtx;
        let keys = {};
        let mouse = { x: 0, y: 0, down: false };
        let camera = { x: 0, y: 0 };
        let currentMap = null;
        let lastUpdateTime = 0;
        let killFeedMessages = [];
        let damageIndicators = [];
        let respawnTimer = 0;
        let gameLoop = null;
        let networkLoop = null;

        // ========================================
        // INITIALIZATION
        // ========================================
        function init() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mousedown', () => mouseDown = true);
            canvas.addEventListener('mouseup', () => mouseDown = false);
            canvas.addEventListener('contextmenu', e => e.preventDefault());

            // Load player data from local storage (will be overwritten by server data on login)
            loadPlayerData();

            // Load saved name for guest login
            const savedName = localStorage.getItem('iconx_name');
            if (savedName) {
                document.getElementById('guestName').value = savedName;
            }

            // Try auto-login from saved credentials
            tryAutoLogin();

            // Connect to cloud server (for online features)
            connectToServer();
        }

        let mouseDown = false;

        // ========================================
        // PLAYER DATA & CURRENCY
        // ========================================
        function loadPlayerData() {
            const saved = localStorage.getItem('iconx_playerData');
            if (saved) {
                const parsed = JSON.parse(saved);
                // Merge with defaults to handle new properties
                playerData = { ...playerData, ...parsed };
                playerData.ownedSkins = { ...playerData.ownedSkins, ...parsed.ownedSkins };
                playerData.equippedSkins = { ...playerData.equippedSkins, ...parsed.equippedSkins };
                playerData.stats = { ...playerData.stats, ...parsed.stats };
                playerData.friends = parsed.friends || [];
            }
        }

        function savePlayerData() {
            localStorage.setItem('iconx_playerData', JSON.stringify(playerData));

            // Also update the local account if logged in
            if (myFriendCode) {
                const accounts = getLocalAccounts();
                if (accounts[myFriendCode]) {
                    accounts[myFriendCode].playerData = { ...playerData };
                    saveLocalAccounts(accounts);
                }
            }
        }

        function updateCurrencyDisplay() {
            document.getElementById('currencyAmount').textContent = playerData.currency;
        }

        function addCurrency(amount) {
            playerData.currency += amount;
            updateCurrencyDisplay();
            savePlayerData();
            showNotification(`+${amount} üíé`, '#f7c531');
        }

        function spendCurrency(amount) {
            if (playerData.currency >= amount) {
                playerData.currency -= amount;
                updateCurrencyDisplay();
                savePlayerData();
                return true;
            }
            return false;
        }

        function showNotification(message, color = '#44ff88') {
            const notif = document.createElement('div');
            notif.className = 'notification';
            notif.style.borderColor = color;
            notif.innerHTML = `<span style="font-size: 24px;">${message}</span>`;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
        }

        // ========================================
        // SHOP SYSTEM
        // ========================================
        function openShop() {
            document.getElementById('shopModal').classList.add('active');
            switchShopTab('blaze');
        }

        function closeShop() {
            document.getElementById('shopModal').classList.remove('active');
        }

        function switchShopTab(heroId) {
            currentShopHero = heroId;

            // Update tab styles
            document.querySelectorAll('.shop-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.textContent.toLowerCase().includes(heroId) ||
                    (heroId === 'healer' && tab.textContent.includes('Sage')) ||
                    (heroId === 'sniper' && tab.textContent.includes('Hawk'))) {
                    tab.classList.add('active');
                }
            });

            renderShopSkins();
        }

        function renderShopSkins() {
            const grid = document.getElementById('shopSkinsGrid');
            const skins = SKINS[currentShopHero];
            const hero = HEROES.find(h => h.id === currentShopHero);

            grid.innerHTML = skins.map(skin => {
                const owned = playerData.ownedSkins[currentShopHero].includes(skin.id);
                const equipped = playerData.equippedSkins[currentShopHero] === skin.id;

                return `
                    <div class="skin-card ${owned ? 'owned' : 'locked'} ${equipped ? 'equipped' : ''}"
                         onclick="${owned ? `equipSkin('${currentShopHero}', '${skin.id}')` : `buySkin('${currentShopHero}', '${skin.id}')`}">
                        ${owned ? '<span class="skin-owned-badge">OWNED</span>' : ''}
                        ${equipped ? '<span class="skin-equipped-badge">EQUIPPED</span>' : ''}
                        <div class="skin-preview" style="background: radial-gradient(circle, ${skin.colors.aura}44 0%, transparent 70%);">
                            <div style="width: 50px; height: 60px; position: relative;">
                                <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 25px; height: 28px; border-radius: 50%; background: linear-gradient(180deg, ${skin.colors.head}, ${skin.colors.body});"></div>
                                <div style="position: absolute; top: 25px; left: 50%; transform: translateX(-50%); width: 30px; height: 25px; border-radius: 5px; background: ${skin.colors.body};"></div>
                                <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; gap: 5px;">
                                    <div style="width: 10px; height: 15px; border-radius: 3px; background: ${skin.colors.legs};"></div>
                                    <div style="width: 10px; height: 15px; border-radius: 3px; background: ${skin.colors.legs};"></div>
                                </div>
                            </div>
                        </div>
                        <div class="skin-name">${skin.name}</div>
                        <div class="skin-rarity ${skin.rarity}">${skin.rarity}</div>
                        ${!owned ? `<div class="skin-price"><span>üíé</span>${skin.price}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        function buySkin(heroId, skinId) {
            const skin = SKINS[heroId].find(s => s.id === skinId);
            if (!skin) return;

            if (playerData.ownedSkins[heroId].includes(skinId)) {
                equipSkin(heroId, skinId);
                return;
            }

            if (skin.price === 0 || spendCurrency(skin.price)) {
                playerData.ownedSkins[heroId].push(skinId);
                playerData.equippedSkins[heroId] = skinId;
                savePlayerData();
                renderShopSkins();
                showNotification(`Unlocked ${skin.name}!`, '#44ff88');
            } else {
                showNotification('Not enough gems!', '#ff4444');
            }
        }

        function equipSkin(heroId, skinId) {
            if (playerData.ownedSkins[heroId].includes(skinId)) {
                playerData.equippedSkins[heroId] = skinId;
                savePlayerData();
                renderShopSkins();
                renderHeroSelection();
                showNotification(`Equipped ${SKINS[heroId].find(s => s.id === skinId).name}`, '#4ecdc4');
            }
        }

        // ========================================
        // QUESTS SYSTEM
        // ========================================
        function openQuests() {
            document.getElementById('questsModal').classList.add('active');
            renderQuests();
        }

        function closeQuests() {
            document.getElementById('questsModal').classList.remove('active');
        }

        function renderQuests() {
            const list = document.getElementById('questsList');

            list.innerHTML = QUESTS.map(quest => {
                const progress = playerData.questProgress[quest.id] || 0;
                const claimed = playerData.claimedQuests.includes(quest.id);
                const completed = progress >= quest.goal;
                const percent = Math.min(100, (progress / quest.goal) * 100);

                return `
                    <div class="quest-card ${completed && claimed ? 'completed' : ''}">
                        <div class="quest-icon">${quest.icon}</div>
                        <div class="quest-info">
                            <div class="quest-title">${quest.title}</div>
                            <div class="quest-desc">${quest.desc}</div>
                            <div class="quest-progress">
                                <div class="quest-progress-fill" style="width: ${percent}%"></div>
                            </div>
                            <div style="font-size: 12px; color: #888; margin-top: 5px;">${progress} / ${quest.goal}</div>
                        </div>
                        <div class="quest-reward">
                            <div class="quest-reward-amount">üíé ${quest.reward}</div>
                            <button class="quest-claim-btn"
                                    onclick="claimQuest('${quest.id}')"
                                    ${!completed || claimed ? 'disabled' : ''}>
                                ${claimed ? 'CLAIMED' : (completed ? 'CLAIM' : 'IN PROGRESS')}
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function claimQuest(questId) {
            const quest = QUESTS.find(q => q.id === questId);
            if (!quest) return;

            const progress = playerData.questProgress[quest.id] || 0;
            if (progress >= quest.goal && !playerData.claimedQuests.includes(questId)) {
                playerData.claimedQuests.push(questId);
                addCurrency(quest.reward);
                renderQuests();
            }
        }

        function updateQuestProgress(type, amount = 1) {
            QUESTS.filter(q => q.type === type).forEach(quest => {
                if (!playerData.claimedQuests.includes(quest.id)) {
                    if (type === 'heroes_played') {
                        // For heroes_played, set the value directly (it's a count of unique heroes)
                        playerData.questProgress[quest.id] = amount;
                    } else {
                        playerData.questProgress[quest.id] = (playerData.questProgress[quest.id] || 0) + amount;
                    }
                }
            });
            savePlayerData();
        }

        // ========================================
        // SKINS COLLECTION
        // ========================================
        function openSkins() {
            document.getElementById('skinsModal').classList.add('active');
            renderCollectionTabs();
            renderCollection();
        }

        function closeSkins() {
            document.getElementById('skinsModal').classList.remove('active');
        }

        function renderCollectionTabs() {
            const tabs = document.getElementById('collectionTabs');
            tabs.innerHTML = HEROES.map(hero => `
                <button class="shop-tab ${hero.id === currentCollectionHero ? 'active' : ''}"
                        onclick="switchCollectionTab('${hero.id}')">
                    ${hero.icon} ${hero.name}
                </button>
            `).join('');
        }

        function switchCollectionTab(heroId) {
            currentCollectionHero = heroId;
            renderCollectionTabs();
            renderCollection();
        }

        function renderCollection() {
            const grid = document.getElementById('collectionGrid');
            const skins = SKINS[currentCollectionHero];

            grid.innerHTML = skins.map(skin => {
                const owned = playerData.ownedSkins[currentCollectionHero].includes(skin.id);
                const equipped = playerData.equippedSkins[currentCollectionHero] === skin.id;

                return `
                    <div class="skin-card ${owned ? 'owned' : 'locked'} ${equipped ? 'equipped' : ''}"
                         onclick="${owned ? `equipSkinFromCollection('${currentCollectionHero}', '${skin.id}')` : ''}">
                        ${owned ? '<span class="skin-owned-badge">OWNED</span>' : ''}
                        ${equipped ? '<span class="skin-equipped-badge">EQUIPPED</span>' : ''}
                        <div class="skin-preview" style="background: radial-gradient(circle, ${skin.colors.aura}44 0%, transparent 70%);">
                            <div style="width: 50px; height: 60px; position: relative;">
                                <div style="position: absolute; top: 0; left: 50%; transform: translateX(-50%); width: 25px; height: 28px; border-radius: 50%; background: linear-gradient(180deg, ${skin.colors.head}, ${skin.colors.body});"></div>
                                <div style="position: absolute; top: 25px; left: 50%; transform: translateX(-50%); width: 30px; height: 25px; border-radius: 5px; background: ${skin.colors.body};"></div>
                                <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; gap: 5px;">
                                    <div style="width: 10px; height: 15px; border-radius: 3px; background: ${skin.colors.legs};"></div>
                                    <div style="width: 10px; height: 15px; border-radius: 3px; background: ${skin.colors.legs};"></div>
                                </div>
                            </div>
                        </div>
                        <div class="skin-name">${skin.name}</div>
                        <div class="skin-rarity ${skin.rarity}">${skin.rarity}</div>
                        ${!owned ? '<div style="color: #666; font-size: 12px;">üîí Locked</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        function equipSkinFromCollection(heroId, skinId) {
            equipSkin(heroId, skinId);
            renderCollection();
        }

        // Get equipped skin colors for a hero
        function getEquippedSkinColors(heroId) {
            const skinId = playerData.equippedSkins[heroId] || 'default';
            const skin = SKINS[heroId]?.find(s => s.id === skinId) || SKINS[heroId]?.[0];
            return skin?.colors || null;
        }

        // Quick equip from hero selection
        function quickEquipSkin(heroId, skinId) {
            equipSkin(heroId, skinId);
            renderHeroSelection();
            renderQuickPlayHeroSelection();
        }

        // Open shop for specific hero
        function openShopForHero(heroId) {
            openShop();
            switchShopTab(heroId);
        }

        // Update stats after a match
        function updateMatchStats(kills, deaths, won, heroId, healingDone = 0) {
            playerData.stats.totalKills += kills;
            playerData.stats.totalDeaths += deaths;
            playerData.stats.matchesPlayed += 1;
            if (won) playerData.stats.wins += 1;
            playerData.stats.healingDone += healingDone;

            // Track heroes played
            if (!playerData.stats.heroesPlayed.includes(heroId)) {
                playerData.stats.heroesPlayed.push(heroId);
            }

            // Update quest progress
            updateQuestProgress('kills', kills);
            updateQuestProgress('matches', 1);
            if (won) updateQuestProgress('wins', 1);
            updateQuestProgress('healing', healingDone);
            updateQuestProgress('heroes_played', playerData.stats.heroesPlayed.length);

            // Give bonus currency based on performance
            const bonus = Math.floor(kills * 10 + (won ? 50 : 10));
            addCurrency(bonus);

            savePlayerData();
        }

        // ========================================
        // FRIENDS SYSTEM (Cloud-based)
        // ========================================
        let friendsOnlineStatus = {};
        let friendStatusCheckInterval = null;

        function initFriendsSystem() {
            // Friend code is now assigned by server on login
            // Load friends list
            if (!playerData.friends) {
                playerData.friends = [];
            }

            // Update friend code display
            const codeEl = document.getElementById('myFriendCode');
            if (codeEl) {
                codeEl.textContent = myFriendCode;
            }
        }

        function openFriends() {
            document.getElementById('friendsModal').classList.add('active');
            document.getElementById('myFriendCode').textContent = myFriendCode || 'Loading...';
            renderFriendsList();

            // Request latest friends list from server
            if (isConnected) {
                sendToServer({ type: 'getFriendsList' });
            }
        }

        function closeFriends() {
            document.getElementById('friendsModal').classList.remove('active');
        }

        function copyFriendCode() {
            navigator.clipboard.writeText(myFriendCode).then(() => {
                showNotification('Friend code copied!', '#44aaff');
            }).catch(() => {
                // Fallback
                const textArea = document.createElement('textarea');
                textArea.value = myFriendCode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showNotification('Friend code copied!', '#44aaff');
            });
        }

        function addFriend() {
            const input = document.getElementById('addFriendInput');
            const code = input.value.trim().toUpperCase().replace(/[^A-Z0-9]/g, '');

            if (!code) {
                showNotification('Please enter a friend code', '#ff4444');
                return;
            }

            if (code === myFriendCode) {
                showNotification("You can't add yourself!", '#ff4444');
                return;
            }

            if (code.length < 6) {
                showNotification('Invalid friend code', '#ff4444');
                return;
            }

            // Send to server
            sendToServer({
                type: 'addFriend',
                friendCode: code
            });

            input.value = '';
        }

        function removeFriend(code) {
            sendToServer({
                type: 'removeFriend',
                friendCode: code
            });
            showNotification('Friend removed', '#888');
        }

        function handleFriendsList(friends) {
            // Update local cache and render
            playerData.friends = friends.map(f => ({
                code: f.code,
                name: f.nickname || f.username,
                username: f.username
            }));

            friends.forEach(f => {
                friendsOnlineStatus[f.code] = {
                    online: f.status !== 'offline',
                    inGame: f.status === 'in-game',
                    roomCode: f.currentGame
                };
            });

            renderFriendsList();
        }

        function renderFriendsList() {
            const list = document.getElementById('friendsList');

            if (!playerData.friends || playerData.friends.length === 0) {
                list.innerHTML = `
                    <div class="no-friends">
                        <div class="no-friends-icon">üë•</div>
                        <div>No friends yet</div>
                        <div style="font-size: 12px; margin-top: 5px;">Share your friend code to connect!</div>
                    </div>
                `;
                return;
            }

            list.innerHTML = playerData.friends.map((friend, index) => {
                const status = friendsOnlineStatus[friend.code] || { online: false, inGame: false, roomCode: null };
                const statusClass = status.inGame ? 'in-game' : (status.online ? 'online' : 'offline');
                const statusText = status.inGame ? `In Game` : (status.online ? 'Online' : 'Offline');

                return `
                    <div class="friend-card">
                        <div class="friend-avatar">
                            üë§
                            <div class="friend-status-dot ${statusClass}"></div>
                        </div>
                        <div class="friend-info">
                            <div class="friend-name" onclick="editFriendName(${index})" style="cursor: pointer;" title="Click to edit nickname">
                                ${friend.name} <span style="font-size: 10px; color: #666;">‚úèÔ∏è</span>
                            </div>
                            <div style="font-size: 10px; color: #555; margin-bottom: 3px;">Code: ${friend.code}</div>
                            <div class="friend-status-text ${statusClass}">${statusText}</div>
                        </div>
                        <div class="friend-actions">
                            ${status.inGame && status.roomCode ? `
                                <button class="friend-action-btn join" onclick="joinFriendGame('${status.roomCode}')" title="Join Game">
                                    üéÆ
                                </button>
                            ` : ''}
                            <button class="friend-action-btn" onclick="shareLobbyWithFriend('${friend.code}')" title="Share Room Code">
                                üìã
                            </button>
                            <button class="friend-action-btn remove" onclick="removeFriend('${friend.code}')" title="Remove Friend">
                                ‚úï
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function editFriendName(index) {
            const friend = playerData.friends[index];
            if (!friend) return;

            const newName = prompt('Enter nickname for this friend:', friend.name);
            if (newName && newName.trim()) {
                friend.name = newName.trim().substring(0, 20);
                savePlayerData();
                renderFriendsList();
                showNotification('Nickname updated!', '#44aaff');
            }
        }

        function shareLobbyWithFriend(friendCode) {
            if (roomId) {
                navigator.clipboard.writeText(roomId).then(() => {
                    showNotification('Room code copied! Share with your friend.', '#44aaff');
                });
            } else {
                showNotification('Create or join a lobby first!', '#ffaa44');
            }
        }

        // Friend status is now handled by server in real-time
        // No need for polling - server pushes status updates

        function joinFriendGame(roomCode) {
            closeFriends();
            // In cloud mode, we could join a friend's game via server
            showNotification('Join friend feature coming soon!', '#44aaff');
        }

        function inviteFriend(friendCode) {
            showNotification('Invite sent!', '#44aaff');
        }

        // Presence is handled by server automatically

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 200;
            minimapCanvas.height = 200;
        }

        // ========================================
        // NETWORKING & MATCHMAKING (Cloud-based)
        // ========================================

        function findMatch() {
            playerName = document.getElementById('playerName').value.trim() || playerName || 'Player';

            if (!isConnected) {
                showNotification('Not connected to server', '#ff4444');
                return;
            }

            showLoading('Searching for match...');

            sendToServer({
                type: 'joinMatchmaking',
                heroId: selectedHero.id
            });
        }

        function cancelMatchmaking() {
            sendToServer({ type: 'leaveMatchmaking' });
            hideLoading();
        }

        function quickPlay() {
            playerName = document.getElementById('playerName').value.trim() || playerName || 'Player';

            // Show hero selection screen
            document.getElementById('menu').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'flex';

            // Render hero selection for quick play
            renderQuickPlayHeroSelection();
        }

        function renderQuickPlayHeroSelection() {
            const grid = document.getElementById('quickPlayHeroesGrid');
            grid.innerHTML = '';

            HEROES.forEach((hero, index) => {
                const card = document.createElement('div');
                card.className = `hero-card ${hero.id === selectedHero.id ? 'selected' : ''}`;
                card.innerHTML = getHeroCharacterHTML(hero);
                card.onclick = () => {
                    selectedHero = hero;
                    renderQuickPlayHeroSelection();
                };
                grid.appendChild(card);
            });
        }

        function cancelQuickPlay() {
            document.getElementById('heroSelect').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
        }

        function startQuickPlayGame() {
            if (!isConnected) {
                showNotification('Not connected to server', '#ff4444');
                return;
            }

            // Hide hero select screen
            document.getElementById('heroSelect').style.display = 'none';

            // Send quick play request to server
            sendToServer({
                type: 'quickPlay',
                heroId: selectedHero.id
            });
        }

        // ========================================
        // PRIVATE ROOMS
        // ========================================
        function createPrivateRoom() {
            if (!isConnected) {
                showNotification('Not connected to server', '#ff4444');
                return;
            }

            // Show hero selection first
            document.getElementById('menu').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'flex';
            renderQuickPlayHeroSelection();

            // Change the start button to create room
            const startBtn = document.querySelector('#heroSelect .btn-primary');
            if (startBtn) {
                startBtn.textContent = 'CREATE ROOM';
                startBtn.onclick = () => {
                    sendToServer({
                        type: 'createRoom',
                        heroId: selectedHero.id
                    });
                    showLoading('Creating room...');
                };
            }
        }

        function joinPrivateRoom() {
            const code = document.getElementById('roomCode').value.trim().toUpperCase();

            if (!code) {
                showNotification('Please enter a room code', '#ff4444');
                return;
            }

            if (!isConnected) {
                showNotification('Not connected to server', '#ff4444');
                return;
            }

            // Show hero selection first
            document.getElementById('menu').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'flex';
            renderQuickPlayHeroSelection();

            // Change the start button to join room
            const startBtn = document.querySelector('#heroSelect .btn-primary');
            if (startBtn) {
                startBtn.textContent = 'JOIN ROOM';
                startBtn.onclick = () => {
                    sendToServer({
                        type: 'joinRoom',
                        roomCode: code,
                        heroId: selectedHero.id
                    });
                    showLoading('Joining room...');
                };
            }
        }

        function updateLoadingText(text) {
            document.getElementById('loadingText').textContent = text;
        }

        // Send player input to server
        function sendInputToServer() {
            if (!isConnected || !gameState || gameState.status !== 'playing') return;

            const me = gameState.players.find(p => p.id === playerId);
            if (!me) return;

            sendToServer({
                type: 'gameInput',
                input: {
                    movement: {
                        x: (keys.d || keys.ArrowRight ? 1 : 0) - (keys.a || keys.ArrowLeft ? 1 : 0),
                        y: (keys.s || keys.ArrowDown ? 1 : 0) - (keys.w || keys.ArrowUp ? 1 : 0)
                    },
                    direction: me.direction || { x: 1, y: 0 },
                    shoot: mouseDown,
                    ability: currentAbility
                }
            });

            currentAbility = null;
        }

        // Input sending interval
        let inputInterval = null;
        let currentAbility = null;

        function startInputSending() {
            if (inputInterval) clearInterval(inputInterval);
            inputInterval = setInterval(sendInputToServer, 1000 / 30); // 30 times per second
        }

        function stopInputSending() {
            if (inputInterval) {
                clearInterval(inputInterval);
                inputInterval = null;
            }
        }

        function leaveGame() {
            sendToServer({ type: 'leaveGame' });
            stopInputSending();
        }

        // Stub function for compatibility - actual broadcasting is handled by server
        function broadcast(data) {
            // In cloud mode, server handles all broadcasting
            console.log('Broadcast (server-handled):', data.type);
        }

        // ========================================
        // LOBBY MANAGEMENT
        // ========================================
        function initHostGameState() {
            gameState = {
                players: [],
                status: 'lobby'
            };

            // Add host as first player
            gameState.players.push({
                id: 0,
                peerId: myId,
                name: playerName,
                heroId: selectedHero.id,
                isBot: false,
                connected: true,
                kills: 0,
                deaths: 0,
                skillRating: 1000
            });

            // Fill with bots
            const botNames = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota'];
            for (let i = 1; i < CONFIG.MAX_PLAYERS; i++) {
                gameState.players.push({
                    id: i,
                    peerId: null,
                    name: `Bot ${botNames[i - 1]}`,
                    heroId: HEROES[Math.floor(Math.random() * HEROES.length)].id,
                    isBot: true,
                    connected: true,
                    kills: 0,
                    deaths: 0,
                    skillRating: 1000
                });
            }

            updateLobbyUI();
        }

        function addPlayerToLobby(peerId, name, heroId) {
            // Find first bot slot and replace
            const botIndex = gameState.players.findIndex(p => p.isBot);
            if (botIndex !== -1) {
                gameState.players[botIndex] = {
                    id: botIndex,
                    peerId: peerId,
                    name: name,
                    heroId: heroId,
                    isBot: false,
                    connected: true,
                    kills: 0,
                    deaths: 0,
                    skillRating: 1000
                };

                // Reset auto-start timer when a new player joins (give them time to pick hero)
                if (isHost && autoStartTimer) {
                    autoStartCountdown = Math.max(autoStartCountdown, 10); // At least 10 seconds
                    updateAutoStartDisplay();
                }
            }
        }

        function showLobby() {
            // In cloud mode, the lobby is less important since server handles matchmaking
            // Game starts automatically when match is found
            document.getElementById('menu').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('roomCodeText').textContent = roomId || 'Waiting...';
            document.getElementById('startBtn').style.display = 'none'; // Server controls start
            document.getElementById('autoStartContainer').style.display = 'none';
        }

        function showLobbyWithCode(code) {
            document.getElementById('menu').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'none';
            document.getElementById('lobby').style.display = 'flex';
            document.getElementById('roomCodeText').textContent = code;
            document.getElementById('startBtn').style.display = 'block';
            document.getElementById('startBtn').textContent = 'START GAME';
            document.getElementById('startBtn').onclick = () => {
                sendToServer({ type: 'startRoom', roomCode: code });
            };
            document.getElementById('autoStartContainer').style.display = 'none';
        }

        function updateRoomLobby(data) {
            // Update player list in lobby
            if (data.players && gameState) {
                gameState.players = data.players;
                updateLobbyUI();
            }

            // If game is starting
            if (data.status === 'starting') {
                currentMap = data.map;
                showNotification('Game starting!', '#44ff88');
            }
        }

        function startAutoStartTimer() {
            autoStartCountdown = AUTO_START_DELAY;
            updateAutoStartDisplay();

            if (autoStartTimer) {
                clearInterval(autoStartTimer);
            }

            autoStartTimer = setInterval(() => {
                autoStartCountdown--;
                updateAutoStartDisplay();

                if (autoStartCountdown <= 0) {
                    clearInterval(autoStartTimer);
                    autoStartTimer = null;
                    startGame();
                }
            }, 1000);
        }

        function updateAutoStartDisplay() {
            const countdownEl = document.getElementById('autoStartCountdown');
            if (countdownEl) {
                countdownEl.textContent = autoStartCountdown;

                // Change color as it gets lower
                if (autoStartCountdown <= 5) {
                    countdownEl.style.color = '#ff4444';
                } else if (autoStartCountdown <= 10) {
                    countdownEl.style.color = '#f7c531';
                } else {
                    countdownEl.style.color = '#ff6b35';
                }
            }
        }

        function stopAutoStartTimer() {
            if (autoStartTimer) {
                clearInterval(autoStartTimer);
                autoStartTimer = null;
            }
        }

        function copyRoomCode() {
            navigator.clipboard.writeText(roomId).then(() => {
                showToast('Room code copied!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = roomId;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showToast('Room code copied!');
            });
        }

        function showToast(message) {
            const toast = document.createElement('div');
            toast.className = 'copy-toast';
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }

        function updateLobbyUI() {
            if (!gameState) return;

            const grid = document.getElementById('playersGrid');
            grid.innerHTML = '';

            let humanCount = 0;

            gameState.players.forEach((player, index) => {
                const hero = HEROES.find(h => h.id === player.heroId) || HEROES[0];
                const isYou = player.peerId === myId;

                if (!player.isBot) humanCount++;

                const slot = document.createElement('div');
                slot.className = `player-slot ${player.isBot ? 'bot' : 'filled'} ${isYou ? 'you' : ''}`;
                slot.innerHTML = `
                    <div class="player-avatar" style="background: ${hero.color}">${hero.icon}</div>
                    <div class="player-name">${player.name}</div>
                    <div class="player-status">${isYou ? 'YOU' : (player.isBot ? 'BOT' : 'PLAYER')}</div>
                `;
                grid.appendChild(slot);
            });

            // Update player count
            const playerCountEl = document.getElementById('playerCount');
            const waitingTextEl = document.getElementById('waitingText');

            if (playerCountEl) {
                playerCountEl.textContent = humanCount;
            }

            if (waitingTextEl) {
                const botCount = 10 - humanCount;
                if (humanCount >= 10) {
                    waitingTextEl.textContent = 'Lobby full!';
                    waitingTextEl.style.color = '#4ecdc4';
                } else if (humanCount >= 2) {
                    waitingTextEl.textContent = `Ready! (${botCount} bots will join)`;
                    waitingTextEl.style.color = '#f7c531';
                } else {
                    waitingTextEl.textContent = `Searching... (${botCount} bots ready)`;
                    waitingTextEl.style.color = '#888';
                }
            }
        }

        function getHeroCharacterHTML(hero, showSkinSelector = true) {
            // Get equipped skin colors
            const skinColors = getEquippedSkinColors(hero.id);

            // Define character accessories based on hero (these don't change with skin)
            const accessories = {
                blaze: {
                    accessory: (aura) => `<div class="char-accessory" style="top: -8px; left: 50%; transform: translateX(-50%); font-size: 20px; text-shadow: 0 0 10px ${aura};">üî•</div>`,
                    helmet: () => ''
                },
                frost: {
                    accessory: (aura) => `<div class="char-accessory" style="top: -5px; left: 50%; transform: translateX(-50%); font-size: 16px; text-shadow: 0 0 10px ${aura};">‚ùÑÔ∏è</div>`,
                    helmet: () => ''
                },
                shadow: {
                    accessory: () => `<div class="char-accessory" style="top: 8px; left: 50%; transform: translateX(-50%); width: 30px; height: 5px; background: linear-gradient(90deg, transparent, #000, transparent); border-radius: 2px;"></div>`,
                    helmet: (colors) => `<div style="position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 20px; height: 15px; background: ${colors.legs}; border-radius: 50% 50% 0 0; z-index: 6;"></div>`
                },
                titan: {
                    accessory: () => `<div class="char-accessory" style="top: 42px; left: 50%; transform: translateX(-50%); width: 20px; height: 25px; background: linear-gradient(180deg, #888, #666); border-radius: 3px 3px 5px 5px; border: 2px solid #555;"></div>`,
                    helmet: () => `<div style="position: absolute; top: -5px; left: 50%; transform: translateX(-50%); width: 38px; height: 12px; background: linear-gradient(180deg, #888, #666); border-radius: 5px 5px 0 0; z-index: 6;"></div>`
                },
                healer: {
                    accessory: (aura) => `<div class="char-accessory" style="top: -5px; left: 50%; transform: translateX(-50%); font-size: 16px; text-shadow: 0 0 10px ${aura};">‚ú®</div>`,
                    helmet: (colors) => `<div style="position: absolute; top: -3px; left: 50%; transform: translateX(-50%); width: 12px; height: 12px; background: #fff; border-radius: 50%; z-index: 6; box-shadow: 0 0 8px ${colors.aura};"></div>`
                },
                sniper: {
                    accessory: () => `<div class="char-accessory" style="top: 35px; right: 2px; width: 35px; height: 5px; background: linear-gradient(90deg, #333, #666, #444); border-radius: 2px; transform: rotate(-25deg); box-shadow: 0 2px 4px rgba(0,0,0,0.5);"></div>`,
                    helmet: (colors) => `<div style="position: absolute; top: 10px; left: 5px; width: 8px; height: 8px; background: ${colors.aura}; border-radius: 50%; z-index: 6; box-shadow: 0 0 5px ${colors.aura};"></div>`
                }
            };

            const acc = accessories[hero.id] || accessories.blaze;
            const colors = skinColors || { head: hero.color, body: hero.color, arms: hero.color, legs: hero.color, aura: hero.color };

            // Skin selector dots
            const ownedSkins = playerData.ownedSkins[hero.id] || ['default'];
            const equippedSkin = playerData.equippedSkins[hero.id] || 'default';
            const allSkins = SKINS[hero.id] || [];

            const skinSelectorHTML = showSkinSelector ? `
                <div class="skin-selector">
                    ${allSkins.map(skin => {
                        const owned = ownedSkins.includes(skin.id);
                        const active = skin.id === equippedSkin;
                        return `<div class="skin-dot ${active ? 'active' : ''} ${!owned ? 'locked' : ''}"
                                    style="background: ${skin.colors.head};"
                                    title="${skin.name}${!owned ? ' (Locked)' : ''}"
                                    onclick="event.stopPropagation(); ${owned ? `quickEquipSkin('${hero.id}', '${skin.id}')` : `openShopForHero('${hero.id}')`}"></div>`;
                    }).join('')}
                </div>
            ` : '';

            return `
                <div class="hero-portrait" style="background: linear-gradient(180deg, ${colors.aura}22 0%, transparent 100%);">
                    <div class="char-aura" style="background: ${colors.aura};"></div>
                    <div class="hero-character">
                        ${acc.accessory(colors.aura)}
                        ${acc.helmet(colors)}
                        <div class="char-head" style="background: linear-gradient(180deg, ${colors.head} 0%, ${colors.body} 100%); box-shadow: 0 3px 10px rgba(0,0,0,0.3);"></div>
                        <div class="char-eyes"></div>
                        <div class="char-body" style="background: linear-gradient(180deg, ${colors.body} 0%, ${colors.arms} 100%); box-shadow: 0 3px 10px rgba(0,0,0,0.3);"></div>
                        <div class="char-arms" style="background: ${colors.arms}; box-shadow: 0 2px 5px rgba(0,0,0,0.3);"></div>
                        <div style="position: absolute; bottom: 0; left: 50%; transform: translateX(-50%); display: flex; gap: 7px;">
                            <div style="width: 14px; height: 22px; background: ${colors.legs}; border-radius: 4px;"></div>
                            <div style="width: 14px; height: 22px; background: ${colors.legs}; border-radius: 4px;"></div>
                        </div>
                    </div>
                </div>
                ${skinSelectorHTML}
                <div class="hero-abilities-preview">
                    ${hero.abilities.map(ab => `
                        <div class="ability-preview" title="${ab.name}">
                            ${ab.icon}
                            <span class="ability-preview-key">${ab.key}</span>
                        </div>
                    `).join('')}
                </div>
                <div class="hero-info">
                    <div class="hero-name" style="color: ${hero.color};">${hero.name}</div>
                    <div class="hero-role ${hero.role.toLowerCase()}">${hero.role}</div>
                    <div class="hero-stats">
                        <div class="hero-stat"><span class="hero-stat-icon">‚ù§Ô∏è</span>${hero.health}</div>
                        <div class="hero-stat"><span class="hero-stat-icon">‚ö°</span>${hero.speed}</div>
                        <div class="hero-stat"><span class="hero-stat-icon">‚öîÔ∏è</span>${hero.attackDamage}</div>
                    </div>
                </div>
            `;
        }

        function renderHeroSelection() {
            const grid = document.getElementById('heroesGrid');
            grid.innerHTML = '';

            HEROES.forEach(hero => {
                const card = document.createElement('div');
                card.className = `hero-card ${hero.id === selectedHero.id ? 'selected' : ''}`;
                card.innerHTML = getHeroCharacterHTML(hero);
                card.onclick = () => selectHero(hero);
                grid.appendChild(card);
            });
        }

        function selectHero(hero) {
            selectedHero = hero;
            renderHeroSelection();

            // Notify server of hero selection
            sendToServer({
                type: 'selectHero',
                heroId: hero.id
            });
        }

        function leaveLobby() {
            sendToServer({ type: 'leaveGame' });
            gameState = null;
            returnToMenu();
        }

        // ========================================
        // MAP GENERATION
        // ========================================
        function generateMap() {
            const theme = MAP_THEMES[Math.floor(Math.random() * MAP_THEMES.length)];

            const map = {
                width: CONFIG.MAP_WIDTH,
                height: CONFIG.MAP_HEIGHT,
                theme: theme,
                walls: [],
                obstacles: [],
                spawnPoints: [],
                healthPacks: []
            };

            // Border walls
            map.walls.push({ x: 0, y: 0, w: map.width, h: 40 });
            map.walls.push({ x: 0, y: map.height - 40, w: map.width, h: 40 });
            map.walls.push({ x: 0, y: 0, w: 40, h: map.height });
            map.walls.push({ x: map.width - 40, y: 0, w: 40, h: map.height });

            // Random interior walls
            for (let i = 0; i < 15; i++) {
                const horizontal = Math.random() > 0.5;
                const wall = {
                    x: 100 + Math.random() * (map.width - 400),
                    y: 100 + Math.random() * (map.height - 400),
                    w: horizontal ? 150 + Math.random() * 200 : 40,
                    h: horizontal ? 40 : 150 + Math.random() * 200
                };
                map.walls.push(wall);
            }

            // Random obstacles (cover)
            for (let i = 0; i < 30; i++) {
                map.obstacles.push({
                    x: 100 + Math.random() * (map.width - 200),
                    y: 100 + Math.random() * (map.height - 200),
                    radius: 20 + Math.random() * 30,
                    type: theme.obstacles
                });
            }

            // Spawn points spread around the map
            for (let i = 0; i < CONFIG.MAX_PLAYERS; i++) {
                const angle = (i / CONFIG.MAX_PLAYERS) * Math.PI * 2;
                const radius = Math.min(map.width, map.height) * 0.35;
                map.spawnPoints.push({
                    x: map.width / 2 + Math.cos(angle) * radius,
                    y: map.height / 2 + Math.sin(angle) * radius
                });
            }

            // Health packs (2 on the map)
            map.healthPacks.push({
                id: 0,
                x: map.width * 0.25,
                y: map.height * 0.5,
                active: true,
                respawnTime: 0,
                healAmount: 75
            });
            map.healthPacks.push({
                id: 1,
                x: map.width * 0.75,
                y: map.height * 0.5,
                active: true,
                respawnTime: 0,
                healAmount: 75
            });

            return map;
        }

        // ========================================
        // GAME START (Cloud-based - server handles game logic)
        // ========================================
        function startGame() {
            // In cloud mode, game is started by server after matchmaking
            // This function is kept for compatibility but no longer used
            console.log('Game start handled by server');
        }

        function startGameplay() {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'none';
            document.getElementById('menu').style.display = 'none';
            document.getElementById('game').style.display = 'block';
            document.getElementById('currencyDisplay').style.display = 'none';

            localPlayer = gameState.players.find(p => p.id === playerId);

            renderAbilityBar();

            // Start game loops
            lastUpdateTime = performance.now();
            gameLoop = requestAnimationFrame(update);

            // Start sending input to server
            startInputSending();
        }

        function renderAbilityBar() {
            const hero = HEROES.find(h => h.id === localPlayer?.heroId) || HEROES[0];
            const bar = document.getElementById('abilityBar');
            bar.innerHTML = '';

            hero.abilities.forEach((ability, index) => {
                const div = document.createElement('div');
                div.className = 'ability ready';
                div.id = `ability-${index}`;
                div.innerHTML = `
                    <span class="ability-icon">${ability.icon}</span>
                    <span class="ability-key">${ability.key}</span>
                    <span class="ability-cooldown"></span>
                `;
                bar.appendChild(div);
            });

            // Dash ability
            const dash = document.createElement('div');
            dash.className = 'ability ready';
            dash.id = 'ability-dash';
            dash.innerHTML = `
                <span class="ability-icon">üí®</span>
                <span class="ability-key">SHIFT</span>
                <span class="ability-cooldown"></span>
            `;
            bar.appendChild(dash);
        }

        // ========================================
        // GAME LOOP (Cloud-based - server handles game state)
        // ========================================
        function update(timestamp) {
            const deltaTime = (timestamp - lastUpdateTime) / 1000;
            lastUpdateTime = timestamp;

            // Update local input direction
            handleInput();

            // Render current game state (received from server)
            render();
            updateHUD();

            gameLoop = requestAnimationFrame(update);
        }

        // hostUpdate not used in cloud mode - kept for compatibility
        function hostUpdate() {
            // Server handles game state updates
            const updateData = {
                type: 'gameUpdate',
                players: gameState.players.map(p => ({
                    id: p.id,
                    x: p.x,
                    y: p.y,
                    angle: p.angle,
                    health: p.health,
                    alive: p.alive,
                    kills: p.kills,
                    deaths: p.deaths,
                    effects: p.effects,
                    shielded: p.shielded,
                    invisible: p.invisible
                })),
                projectiles: gameState.projectiles,
                areas: gameState.areas,
                traps: gameState.traps
            };
            broadcast(updateData);
        }

        function updateFromServer(data) {
            if (!gameState) return;

            data.players.forEach(serverPlayer => {
                const player = gameState.players.find(p => p.id === serverPlayer.id);
                if (player) {
                    if (player.peerId !== myId) {
                        player.x = serverPlayer.x;
                        player.y = serverPlayer.y;
                        player.angle = serverPlayer.angle;
                    }
                    player.health = serverPlayer.health;
                    player.alive = serverPlayer.alive;
                    player.kills = serverPlayer.kills;
                    player.deaths = serverPlayer.deaths;
                    player.effects = serverPlayer.effects;
                    player.shielded = serverPlayer.shielded;
                    player.invisible = serverPlayer.invisible;
                }
            });

            gameState.projectiles = data.projectiles;
            gameState.areas = data.areas;
            gameState.traps = data.traps;
        }

        function updateGameState(deltaTime) {
            // Update all players
            gameState.players.forEach(player => {
                if (player.isBot) {
                    updateBotAI(player, deltaTime);
                }
                updatePlayer(player, deltaTime);
            });

            // Update projectiles
            updateProjectiles(deltaTime);

            // Update areas
            updateAreas(deltaTime);

            // Update traps
            updateTraps(deltaTime);

            // Update health packs
            updateHealthPacks(deltaTime);

            // Check for winner
            const leader = gameState.players.reduce((a, b) => a.kills > b.kills ? a : b);
            if (leader.kills >= CONFIG.KILL_GOAL) {
                endGame(leader);
            }
        }

        function updatePlayer(player, deltaTime) {
            if (!player.alive) {
                player.respawnTime -= deltaTime;
                if (player.respawnTime <= 0) {
                    respawnPlayer(player);
                }
                return;
            }

            const hero = HEROES.find(h => h.id === player.heroId) || HEROES[0];
            const input = player.input;
            const speed = hero.speed * (player.effects.includes('slow') ? 0.5 : 1);

            // Movement
            let dx = 0, dy = 0;
            if (input.up) dy -= 1;
            if (input.down) dy += 1;
            if (input.left) dx -= 1;
            if (input.right) dx += 1;

            if (dx !== 0 || dy !== 0) {
                const len = Math.sqrt(dx * dx + dy * dy);
                dx /= len;
                dy /= len;
            }

            const newX = player.x + dx * speed * 60 * deltaTime;
            const newY = player.y + dy * speed * 60 * deltaTime;

            // Collision check
            if (!checkCollision(newX, player.y, 20)) {
                player.x = newX;
            }
            if (!checkCollision(player.x, newY, 20)) {
                player.y = newY;
            }

            // Keep in bounds
            player.x = Math.max(50, Math.min(currentMap.width - 50, player.x));
            player.y = Math.max(50, Math.min(currentMap.height - 50, player.y));

            player.angle = input.angle;

            // Cooldowns
            player.attackCooldown = Math.max(0, player.attackCooldown - deltaTime);
            player.dashCooldown = Math.max(0, player.dashCooldown - deltaTime);
            for (let i = 0; i < 3; i++) {
                player.cooldowns[i] = Math.max(0, player.cooldowns[i] - deltaTime);
            }

            // Attack
            if (input.attack && player.attackCooldown <= 0) {
                attack(player, hero);
                player.attackCooldown = hero.attackSpeed;
            }

            // Abilities
            for (let i = 0; i < 3; i++) {
                if (input.abilities[i] && player.cooldowns[i] <= 0) {
                    useAbility(player, hero, i);
                    player.cooldowns[i] = hero.abilities[i].cooldown;
                }
            }

            // Dash
            if (input.dash && player.dashCooldown <= 0) {
                const dashDist = 150;
                const dashX = player.x + Math.cos(player.angle) * dashDist;
                const dashY = player.y + Math.sin(player.angle) * dashDist;

                if (!checkCollision(dashX, dashY, 20)) {
                    player.x = dashX;
                    player.y = dashY;
                }
                player.dashCooldown = 3;
            }

            // Update effects
            player.effects = player.effects.filter(e => e !== 'slow' || Math.random() > deltaTime);
        }

        function attack(player, hero) {
            if (hero.projectileSpeed > 0) {
                // Ranged attack
                gameState.projectiles.push({
                    x: player.x,
                    y: player.y,
                    vx: Math.cos(player.angle) * hero.projectileSpeed,
                    vy: Math.sin(player.angle) * hero.projectileSpeed,
                    damage: hero.attackDamage,
                    ownerId: player.id,
                    range: hero.attackRange,
                    traveled: 0,
                    color: hero.color
                });
            } else {
                // Melee attack
                gameState.players.forEach(target => {
                    if (target.id !== player.id && target.alive) {
                        const dist = Math.hypot(target.x - player.x, target.y - player.y);
                        if (dist < hero.attackRange) {
                            dealDamage(target, hero.attackDamage, player);
                        }
                    }
                });
            }
        }

        function useAbility(player, hero, index) {
            const ability = hero.abilities[index];

            switch (ability.type) {
                case 'projectile':
                    gameState.projectiles.push({
                        x: player.x,
                        y: player.y,
                        vx: Math.cos(player.angle) * ability.speed,
                        vy: Math.sin(player.angle) * ability.speed,
                        damage: ability.damage,
                        ownerId: player.id,
                        range: ability.range,
                        traveled: 0,
                        color: hero.color,
                        isAbility: true
                    });
                    break;

                case 'area':
                case 'ultimate':
                    if (ability.radius) {
                        gameState.areas.push({
                            x: player.x + Math.cos(player.angle) * 100,
                            y: player.y + Math.sin(player.angle) * 100,
                            radius: ability.radius,
                            damage: ability.damage,
                            ownerId: player.id,
                            duration: ability.duration || 0.5,
                            color: hero.color
                        });
                    }
                    break;

                case 'teleport':
                    const blinkX = player.x + Math.cos(player.angle) * ability.range;
                    const blinkY = player.y + Math.sin(player.angle) * ability.range;
                    if (!checkCollision(blinkX, blinkY, 20)) {
                        player.x = blinkX;
                        player.y = blinkY;
                    }
                    break;

                case 'melee':
                    gameState.players.forEach(target => {
                        if (target.id !== player.id && target.alive) {
                            const dist = Math.hypot(target.x - player.x, target.y - player.y);
                            if (dist < ability.range) {
                                dealDamage(target, ability.damage, player);
                            }
                        }
                    });
                    break;

                case 'dash':
                    const chargeX = player.x + Math.cos(player.angle) * ability.range;
                    const chargeY = player.y + Math.sin(player.angle) * ability.range;

                    // Deal damage to players in path
                    gameState.players.forEach(target => {
                        if (target.id !== player.id && target.alive) {
                            const dist = pointToLineDistance(target.x, target.y, player.x, player.y, chargeX, chargeY);
                            if (dist < 50) {
                                dealDamage(target, ability.damage, player);
                            }
                        }
                    });

                    if (!checkCollision(chargeX, chargeY, 20)) {
                        player.x = chargeX;
                        player.y = chargeY;
                    }
                    break;

                case 'buff':
                    player.shielded = true;
                    setTimeout(() => { player.shielded = false; }, ability.duration * 1000);
                    break;

                case 'heal':
                    // Heal self or nearby allies (in FFA, just self)
                    player.health = Math.min(player.maxHealth, player.health - ability.damage); // Negative damage = heal
                    break;

                case 'cc':
                    gameState.players.forEach(target => {
                        if (target.id !== player.id && target.alive) {
                            const dist = Math.hypot(target.x - player.x, target.y - player.y);
                            if (dist < 200) {
                                target.effects.push('slow');
                                dealDamage(target, ability.damage, player);
                            }
                        }
                    });
                    break;

                case 'trap':
                    gameState.traps.push({
                        x: player.x,
                        y: player.y,
                        radius: 30,
                        damage: ability.damage,
                        ownerId: player.id,
                        duration: ability.duration,
                        color: hero.color
                    });
                    break;
            }
        }

        function updateProjectiles(deltaTime) {
            gameState.projectiles = gameState.projectiles.filter(proj => {
                proj.x += proj.vx;
                proj.y += proj.vy;
                proj.traveled += Math.hypot(proj.vx, proj.vy);

                // Check wall collision
                if (checkCollision(proj.x, proj.y, 5)) {
                    return false;
                }

                // Check player collision
                for (const player of gameState.players) {
                    if (player.id !== proj.ownerId && player.alive) {
                        const dist = Math.hypot(player.x - proj.x, player.y - proj.y);
                        if (dist < 25) {
                            const owner = gameState.players.find(p => p.id === proj.ownerId);
                            dealDamage(player, proj.damage, owner);
                            return false;
                        }
                    }
                }

                return proj.traveled < proj.range;
            });
        }

        function updateAreas(deltaTime) {
            gameState.areas = gameState.areas.filter(area => {
                area.duration -= deltaTime;

                // Deal damage to players in area
                gameState.players.forEach(player => {
                    if (player.id !== area.ownerId && player.alive) {
                        const dist = Math.hypot(player.x - area.x, player.y - area.y);
                        if (dist < area.radius) {
                            const owner = gameState.players.find(p => p.id === area.ownerId);
                            dealDamage(player, area.damage * deltaTime, owner);
                        }
                    }
                });

                return area.duration > 0;
            });
        }

        function updateTraps(deltaTime) {
            gameState.traps = gameState.traps.filter(trap => {
                trap.duration -= deltaTime;

                // Check if player steps on trap
                gameState.players.forEach(player => {
                    if (player.id !== trap.ownerId && player.alive) {
                        const dist = Math.hypot(player.x - trap.x, player.y - trap.y);
                        if (dist < trap.radius + 20) {
                            const owner = gameState.players.find(p => p.id === trap.ownerId);
                            dealDamage(player, trap.damage, owner);
                            player.effects.push('slow');
                            trap.duration = 0; // Remove trap
                        }
                    }
                });

                return trap.duration > 0;
            });
        }

        function updateHealthPacks(deltaTime) {
            if (!currentMap || !currentMap.healthPacks) return;

            currentMap.healthPacks.forEach(pack => {
                if (!pack.active) {
                    // Respawn timer
                    pack.respawnTime -= deltaTime;
                    if (pack.respawnTime <= 0) {
                        pack.active = true;
                    }
                    return;
                }

                // Check if player picks up health pack
                gameState.players.forEach(player => {
                    if (player.alive && pack.active) {
                        const dist = Math.hypot(player.x - pack.x, player.y - pack.y);
                        if (dist < 40) {
                            // Only pick up if not at full health
                            if (player.health < player.maxHealth) {
                                player.health = Math.min(player.maxHealth, player.health + pack.healAmount);
                                pack.active = false;
                                pack.respawnTime = 15; // Respawn after 15 seconds

                                // Show heal indicator for local player
                                if (player.peerId === myId) {
                                    damageIndicators.push({
                                        x: player.x + (Math.random() - 0.5) * 40,
                                        y: player.y - 20,
                                        damage: '+' + pack.healAmount,
                                        time: 1,
                                        isHeal: true
                                    });
                                }
                            }
                        }
                    }
                });
            });
        }

        function dealDamage(player, damage, attacker) {
            if (player.shielded) {
                damage *= 0.5;
            }

            player.health -= damage;

            // Add damage indicator
            if (player.peerId === myId) {
                damageIndicators.push({
                    x: player.x + (Math.random() - 0.5) * 40,
                    y: player.y - 20,
                    damage: Math.round(damage),
                    time: 1
                });
            }

            if (player.health <= 0) {
                player.health = 0;
                player.alive = false;
                player.respawnTime = CONFIG.RESPAWN_TIME;
                player.deaths++;

                if (attacker) {
                    attacker.kills++;
                    broadcast({ type: 'kill', killer: attacker.name, victim: player.name });
                    addKillFeedMessage(attacker.name, player.name);
                }
            }
        }

        function respawnPlayer(player) {
            const spawn = currentMap.spawnPoints[Math.floor(Math.random() * currentMap.spawnPoints.length)];
            const hero = HEROES.find(h => h.id === player.heroId) || HEROES[0];

            player.x = spawn.x;
            player.y = spawn.y;
            player.health = hero.health;
            player.alive = true;
            player.effects = [];
            player.shielded = false;
        }

        function checkCollision(x, y, radius) {
            // Check walls
            for (const wall of currentMap.walls) {
                if (x + radius > wall.x && x - radius < wall.x + wall.w &&
                    y + radius > wall.y && y - radius < wall.y + wall.h) {
                    return true;
                }
            }

            // Check obstacles
            for (const obs of currentMap.obstacles) {
                const dist = Math.hypot(x - obs.x, y - obs.y);
                if (dist < radius + obs.radius) {
                    return true;
                }
            }

            return false;
        }

        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let param = -1;
            if (lenSq !== 0) param = dot / lenSq;
            let xx, yy;
            if (param < 0) { xx = x1; yy = y1; }
            else if (param > 1) { xx = x2; yy = y2; }
            else { xx = x1 + param * C; yy = y1 + param * D; }
            return Math.hypot(px - xx, py - yy);
        }

        // ========================================
        // BOT AI
        // ========================================
        function updateBotAI(bot, deltaTime) {
            if (!bot.alive) return;

            const hero = HEROES.find(h => h.id === bot.heroId) || HEROES[0];

            // Find nearest enemy
            let nearestEnemy = null;
            let nearestDist = Infinity;

            gameState.players.forEach(player => {
                if (player.id !== bot.id && player.alive && !player.invisible) {
                    const dist = Math.hypot(player.x - bot.x, player.y - bot.y);
                    if (dist < nearestDist) {
                        nearestDist = dist;
                        nearestEnemy = player;
                    }
                }
            });

            // Reset input
            bot.input = { up: false, down: false, left: false, right: false, attack: false, abilities: [false, false, false], dash: false, angle: bot.angle };

            if (nearestEnemy) {
                const dx = nearestEnemy.x - bot.x;
                const dy = nearestEnemy.y - bot.y;
                bot.input.angle = Math.atan2(dy, dx);

                // Dynamic skill - bots adapt to match human player performance
                const humanPlayer = gameState.players.find(p => !p.isBot && p.peerId === myId);
                if (humanPlayer) {
                    // Adjust bot skill based on player's K/D ratio
                    const playerKD = humanPlayer.deaths > 0 ? humanPlayer.kills / humanPlayer.deaths : humanPlayer.kills;
                    if (playerKD > 2) {
                        bot.skillRating = Math.min(1500, bot.skillRating + 1); // Player doing well, bots get harder
                    } else if (playerKD < 0.5) {
                        bot.skillRating = Math.max(500, bot.skillRating - 1); // Player struggling, bots get easier
                    }
                }

                // Skill-based decision making
                const skillFactor = bot.skillRating / 1000;
                const reactionTime = 0.3 / skillFactor;
                const accuracy = 0.5 + skillFactor * 0.4;

                // Add some randomness to aiming based on skill
                bot.input.angle += (Math.random() - 0.5) * (1 - accuracy) * 0.5;

                // Movement AI
                if (nearestDist > hero.attackRange * 0.8) {
                    // Move towards enemy
                    if (dx > 50) bot.input.right = true;
                    else if (dx < -50) bot.input.left = true;
                    if (dy > 50) bot.input.down = true;
                    else if (dy < -50) bot.input.up = true;
                } else if (nearestDist < hero.attackRange * 0.3) {
                    // Too close, back up (for ranged)
                    if (hero.projectileSpeed > 0) {
                        if (dx > 0) bot.input.left = true;
                        else bot.input.right = true;
                        if (dy > 0) bot.input.up = true;
                        else bot.input.down = true;
                    }
                }

                // Attack if in range
                if (nearestDist < hero.attackRange && Math.random() < skillFactor) {
                    bot.input.attack = true;
                }

                // Use abilities based on skill
                if (Math.random() < skillFactor * 0.1) {
                    for (let i = 0; i < 3; i++) {
                        if (bot.cooldowns[i] <= 0 && Math.random() < 0.3) {
                            bot.input.abilities[i] = true;
                        }
                    }
                }

                // Dash to dodge or chase
                if (bot.dashCooldown <= 0 && Math.random() < skillFactor * 0.05) {
                    bot.input.dash = true;
                }

                // Strafe while fighting
                if (Math.random() < 0.3) {
                    if (Math.random() > 0.5) {
                        bot.input.left = !bot.input.left;
                        bot.input.right = !bot.input.right;
                    } else {
                        bot.input.up = !bot.input.up;
                        bot.input.down = !bot.input.down;
                    }
                }
            } else {
                // Wander
                if (Math.random() < 0.02) {
                    bot.wanderAngle = Math.random() * Math.PI * 2;
                }
                if (bot.wanderAngle !== undefined) {
                    bot.input.angle = bot.wanderAngle;
                    if (Math.cos(bot.wanderAngle) > 0.3) bot.input.right = true;
                    else if (Math.cos(bot.wanderAngle) < -0.3) bot.input.left = true;
                    if (Math.sin(bot.wanderAngle) > 0.3) bot.input.down = true;
                    else if (Math.sin(bot.wanderAngle) < -0.3) bot.input.up = true;
                }
            }
        }

        // ========================================
        // INPUT HANDLING
        // ========================================
        function handleKeyDown(e) {
            // Don't capture keys when typing in input fields
            if (document.activeElement.tagName === 'INPUT') {
                return;
            }

            keys[e.code] = true;

            // Prevent default for game keys
            if (['KeyW', 'KeyA', 'KeyS', 'KeyD', 'KeyQ', 'KeyE', 'KeyR', 'ShiftLeft', 'ShiftRight'].includes(e.code)) {
                e.preventDefault();
            }
        }

        function handleKeyUp(e) {
            // Don't capture keys when typing in input fields
            if (document.activeElement.tagName === 'INPUT') {
                return;
            }

            keys[e.code] = false;
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        }

        function handleInput() {
            const me = gameState?.players?.find(p => p.id === playerId);
            if (!me || !me.alive) return;

            // Calculate direction based on mouse position
            const angle = Math.atan2(
                mouse.y - canvas.height / 2,
                mouse.x - canvas.width / 2
            );

            me.direction = {
                x: Math.cos(angle),
                y: Math.sin(angle)
            };
            me.angle = angle;

            // Track ability usage
            if (keys['KeyQ']) currentAbility = 'q';
            else if (keys['KeyE']) currentAbility = 'e';
            else if (keys['KeyR']) currentAbility = 'r';

            localPlayer = me;
        }

        // ========================================
        // RENDERING
        // ========================================
        // Helper function for color shading
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        // RoundRect polyfill
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.moveTo(x + r, y);
                this.arcTo(x + w, y, x + w, y + h, r);
                this.arcTo(x + w, y + h, x, y + h, r);
                this.arcTo(x, y + h, x, y, r);
                this.arcTo(x, y, x + w, y, r);
                this.closePath();
                return this;
            };
        }

        function render() {
            if (!currentMap || !gameState) return;

            // Update camera
            if (localPlayer) {
                camera.x = localPlayer.x - canvas.width / 2;
                camera.y = localPlayer.y - canvas.height / 2;
            }

            // Clear
            ctx.fillStyle = currentMap.theme.bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(-camera.x, -camera.y);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            const gridSize = 100;
            for (let x = 0; x < currentMap.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, currentMap.height);
                ctx.stroke();
            }
            for (let y = 0; y < currentMap.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(currentMap.width, y);
                ctx.stroke();
            }

            // Draw walls
            ctx.fillStyle = currentMap.theme.wallColor;
            currentMap.walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
            });

            // Draw obstacles
            currentMap.obstacles.forEach(obs => {
                ctx.fillStyle = currentMap.theme.wallColor;
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = currentMap.theme.accentColor;
                ctx.lineWidth = 2;
                ctx.stroke();
            });

            // Draw health packs
            currentMap.healthPacks?.forEach(pack => {
                if (!pack.active) return;

                // Glow effect
                ctx.shadowColor = '#44ff88';
                ctx.shadowBlur = 20;

                // Health pack base
                ctx.fillStyle = '#44ff88';
                ctx.beginPath();
                ctx.arc(pack.x, pack.y, 25, 0, Math.PI * 2);
                ctx.fill();

                // Cross symbol
                ctx.fillStyle = '#fff';
                ctx.fillRect(pack.x - 12, pack.y - 4, 24, 8);
                ctx.fillRect(pack.x - 4, pack.y - 12, 8, 24);

                ctx.shadowBlur = 0;

                // Pulsing ring
                const pulse = Math.sin(Date.now() / 200) * 5 + 30;
                ctx.strokeStyle = 'rgba(68, 255, 136, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(pack.x, pack.y, pulse, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw traps
            gameState.traps?.forEach(trap => {
                // Warning pattern
                const time = Date.now() / 500;
                const blink = Math.sin(time) > 0;

                ctx.fillStyle = blink ? trap.color + '55' : trap.color + '33';
                ctx.beginPath();
                ctx.arc(trap.x, trap.y, trap.radius, 0, Math.PI * 2);
                ctx.fill();

                // Danger stripes
                ctx.save();
                ctx.beginPath();
                ctx.arc(trap.x, trap.y, trap.radius, 0, Math.PI * 2);
                ctx.clip();

                ctx.strokeStyle = trap.color + '66';
                ctx.lineWidth = 4;
                for (let i = -trap.radius * 2; i < trap.radius * 2; i += 10) {
                    ctx.beginPath();
                    ctx.moveTo(trap.x + i, trap.y - trap.radius);
                    ctx.lineTo(trap.x + i + trap.radius, trap.y + trap.radius);
                    ctx.stroke();
                }
                ctx.restore();

                // Border
                ctx.strokeStyle = trap.color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(trap.x, trap.y, trap.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Warning icon
                ctx.fillStyle = trap.color;
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚ö†', trap.x, trap.y);
            });

            // Draw areas
            gameState.areas?.forEach(area => {
                // Pulsing effect
                const pulse = Math.sin(Date.now() / 100) * 0.2 + 0.8;

                // Gradient fill
                const areaGradient = ctx.createRadialGradient(area.x, area.y, 0, area.x, area.y, area.radius);
                areaGradient.addColorStop(0, area.color + '66');
                areaGradient.addColorStop(0.7, area.color + '33');
                areaGradient.addColorStop(1, area.color + '00');
                ctx.fillStyle = areaGradient;
                ctx.beginPath();
                ctx.arc(area.x, area.y, area.radius * pulse, 0, Math.PI * 2);
                ctx.fill();

                // Outer ring
                ctx.strokeStyle = area.color;
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.arc(area.x, area.y, area.radius, 0, Math.PI * 2);
                ctx.stroke();
                ctx.setLineDash([]);

                // Inner glow ring
                ctx.strokeStyle = area.color + '88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(area.x, area.y, area.radius * 0.6, 0, Math.PI * 2);
                ctx.stroke();
            });

            // Draw projectiles
            gameState.projectiles?.forEach(proj => {
                const size = proj.isAbility ? 12 : 8;

                // Glow effect
                ctx.shadowColor = proj.color;
                ctx.shadowBlur = proj.isAbility ? 20 : 10;

                // Trail
                const trailLength = proj.isAbility ? 4 : 3;
                for (let i = trailLength; i > 0; i--) {
                    const alpha = (1 - i / trailLength) * 0.5;
                    ctx.fillStyle = proj.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                    ctx.beginPath();
                    ctx.arc(
                        proj.x - proj.vx * i * 0.5,
                        proj.y - proj.vy * i * 0.5,
                        size * (1 - i / (trailLength + 2)),
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }

                // Main projectile
                const projGradient = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, size);
                projGradient.addColorStop(0, '#fff');
                projGradient.addColorStop(0.3, proj.color);
                projGradient.addColorStop(1, shadeColor(proj.color, -30));
                ctx.fillStyle = projGradient;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 0;
            });

            // Draw players
            gameState.players.forEach(player => {
                if (!player.alive || player.invisible) return;

                const hero = HEROES.find(h => h.id === player.heroId) || HEROES[0];
                const isLocal = player.peerId === myId;

                // Get skin colors (use equipped skin for local player, default for others/bots)
                let skinColors;
                if (isLocal) {
                    skinColors = getEquippedSkinColors(hero.id);
                } else {
                    skinColors = SKINS[hero.id]?.[0]?.colors || { head: hero.color, body: hero.color, aura: hero.color };
                }
                const playerColor = skinColors?.head || hero.color;
                const auraColor = skinColors?.aura || hero.color;

                ctx.save();
                ctx.translate(player.x, player.y);

                // Glow/aura effect
                const gradient = ctx.createRadialGradient(0, 0, 15, 0, 0, 40);
                gradient.addColorStop(0, auraColor + '44');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 40, 0, Math.PI * 2);
                ctx.fill();

                // Shield effect
                if (player.shielded) {
                    ctx.strokeStyle = '#44ff88';
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.arc(0, 0, 38, 0, Math.PI * 2);
                    ctx.stroke();

                    // Shield glow
                    ctx.shadowColor = '#44ff88';
                    ctx.shadowBlur = 15;
                }

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(0, 18, 18, 8, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // Character body (capsule shape)
                const bodyGradient = ctx.createLinearGradient(-15, -25, 15, 25);
                bodyGradient.addColorStop(0, skinColors?.body || playerColor);
                bodyGradient.addColorStop(0.5, skinColors?.body || playerColor);
                bodyGradient.addColorStop(1, shadeColor(skinColors?.legs || playerColor, -20));
                ctx.fillStyle = bodyGradient;

                // Draw body
                ctx.beginPath();
                ctx.moveTo(-12, -15);
                ctx.lineTo(-12, 10);
                ctx.quadraticCurveTo(-12, 18, 0, 18);
                ctx.quadraticCurveTo(12, 18, 12, 10);
                ctx.lineTo(12, -15);
                ctx.quadraticCurveTo(12, -25, 0, -25);
                ctx.quadraticCurveTo(-12, -25, -12, -15);
                ctx.fill();

                // Body outline
                ctx.strokeStyle = shadeColor(skinColors?.legs || playerColor, -40);
                ctx.lineWidth = 2;
                ctx.stroke();

                // Head
                ctx.fillStyle = playerColor;
                ctx.beginPath();
                ctx.arc(0, -18, 14, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = shadeColor(playerColor, -40);
                ctx.lineWidth = 2;
                ctx.stroke();

                // Eyes (looking in direction)
                const eyeOffsetX = Math.cos(player.angle) * 3;
                const eyeOffsetY = Math.sin(player.angle) * 2;

                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.ellipse(-5 + eyeOffsetX * 0.5, -20 + eyeOffsetY * 0.5, 4, 5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(5 + eyeOffsetX * 0.5, -20 + eyeOffsetY * 0.5, 4, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Pupils
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(-5 + eyeOffsetX, -20 + eyeOffsetY, 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(5 + eyeOffsetX, -20 + eyeOffsetY, 2, 0, Math.PI * 2);
                ctx.fill();

                // Direction indicator (weapon/arm pointing)
                ctx.strokeStyle = shadeColor(skinColors?.arms || playerColor, -20);
                ctx.lineWidth = 6;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(Math.cos(player.angle) * 10, -5 + Math.sin(player.angle) * 5);
                ctx.lineTo(Math.cos(player.angle) * 30, -5 + Math.sin(player.angle) * 20);
                ctx.stroke();

                // Weapon tip glow
                ctx.fillStyle = auraColor;
                ctx.beginPath();
                ctx.arc(Math.cos(player.angle) * 32, -5 + Math.sin(player.angle) * 22, 4, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore();

                // Health bar (outside transform)
                const healthBarWidth = 50;
                const healthBarHeight = 6;
                const healthPercent = player.health / player.maxHealth;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.roundRect(player.x - healthBarWidth / 2 - 2, player.y - 48, healthBarWidth + 4, healthBarHeight + 4, 3);
                ctx.fill();

                ctx.fillStyle = '#333';
                ctx.fillRect(player.x - healthBarWidth / 2, player.y - 46, healthBarWidth, healthBarHeight);

                const healthGradient = ctx.createLinearGradient(player.x - healthBarWidth / 2, 0, player.x + healthBarWidth / 2, 0);
                if (healthPercent > 0.5) {
                    healthGradient.addColorStop(0, '#44ff88');
                    healthGradient.addColorStop(1, '#22cc66');
                } else if (healthPercent > 0.25) {
                    healthGradient.addColorStop(0, '#ffaa44');
                    healthGradient.addColorStop(1, '#ff8822');
                } else {
                    healthGradient.addColorStop(0, '#ff4444');
                    healthGradient.addColorStop(1, '#cc2222');
                }
                ctx.fillStyle = healthGradient;
                ctx.fillRect(player.x - healthBarWidth / 2, player.y - 46, healthBarWidth * healthPercent, healthBarHeight);

                // Name with background
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                const nameWidth = ctx.measureText(player.name).width;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.beginPath();
                ctx.roundRect(player.x - nameWidth / 2 - 5, player.y - 62, nameWidth + 10, 16, 4);
                ctx.fill();

                ctx.fillStyle = isLocal ? '#4ecdc4' : '#fff';
                ctx.fillText(player.name, player.x, player.y - 50);

                // Local player indicator
                if (isLocal) {
                    ctx.strokeStyle = '#4ecdc4';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(player.x, player.y, 35, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });

            ctx.restore();

            // Render minimap
            renderMinimap();

            // Render damage indicators
            renderDamageIndicators();

            // Render respawn timer
            renderRespawnTimer();
        }

        function renderMinimap() {
            const scale = 200 / Math.max(currentMap.width, currentMap.height);

            minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            minimapCtx.fillRect(0, 0, 200, 200);

            // Draw walls
            minimapCtx.fillStyle = currentMap.theme.wallColor;
            currentMap.walls.forEach(wall => {
                minimapCtx.fillRect(wall.x * scale, wall.y * scale, wall.w * scale, wall.h * scale);
            });

            // Draw health packs
            currentMap.healthPacks?.forEach(pack => {
                if (!pack.active) return;
                minimapCtx.fillStyle = '#44ff88';
                minimapCtx.beginPath();
                minimapCtx.arc(pack.x * scale, pack.y * scale, 4, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Draw players
            gameState.players.forEach(player => {
                if (!player.alive) return;

                const hero = HEROES.find(h => h.id === player.heroId) || HEROES[0];
                const isLocal = player.peerId === myId;

                // Get skin color for local player
                let dotColor = hero.color;
                if (isLocal) {
                    const skinColors = getEquippedSkinColors(hero.id);
                    dotColor = skinColors?.aura || hero.color;
                }

                minimapCtx.fillStyle = isLocal ? '#4ecdc4' : dotColor;
                minimapCtx.beginPath();
                minimapCtx.arc(player.x * scale, player.y * scale, isLocal ? 5 : 3, 0, Math.PI * 2);
                minimapCtx.fill();
            });

            // Camera view
            minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(
                camera.x * scale,
                camera.y * scale,
                canvas.width * scale,
                canvas.height * scale
            );
        }

        function renderDamageIndicators() {
            damageIndicators = damageIndicators.filter(ind => {
                ind.time -= 0.016;
                ind.y -= 1;

                if (ind.isHeal) {
                    ctx.fillStyle = `rgba(68, 255, 136, ${ind.time})`;
                    ctx.font = 'bold 22px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(ind.damage, ind.x - camera.x, ind.y - camera.y);
                } else {
                    ctx.fillStyle = `rgba(255, 68, 68, ${ind.time})`;
                    ctx.font = 'bold 20px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(`-${ind.damage}`, ind.x - camera.x, ind.y - camera.y);
                }

                return ind.time > 0;
            });
        }

        function renderRespawnTimer() {
            const timer = document.getElementById('respawnTimer');

            if (localPlayer && !localPlayer.alive) {
                timer.style.display = 'block';
                timer.textContent = Math.ceil(localPlayer.respawnTime);
            } else {
                timer.style.display = 'none';
            }
        }

        // ========================================
        // HUD
        // ========================================
        function updateHUD() {
            if (!localPlayer) return;

            const hero = HEROES.find(h => h.id === localPlayer.heroId) || HEROES[0];

            // Health
            const healthPercent = (localPlayer.health / localPlayer.maxHealth) * 100;
            document.getElementById('healthFill').style.width = healthPercent + '%';
            document.getElementById('healthText').textContent = `${Math.ceil(localPlayer.health)}/${localPlayer.maxHealth}`;

            // Abilities
            hero.abilities.forEach((ability, index) => {
                const el = document.getElementById(`ability-${index}`);
                if (el) {
                    const cooldown = localPlayer.cooldowns[index];
                    el.className = `ability ${cooldown <= 0 ? 'ready' : 'cooldown'}`;
                    el.querySelector('.ability-cooldown').textContent = cooldown > 0 ? Math.ceil(cooldown) : '';
                }
            });

            // Dash
            const dashEl = document.getElementById('ability-dash');
            if (dashEl) {
                const dashCooldown = localPlayer.dashCooldown;
                dashEl.className = `ability ${dashCooldown <= 0 ? 'ready' : 'cooldown'}`;
                dashEl.querySelector('.ability-cooldown').textContent = dashCooldown > 0 ? Math.ceil(dashCooldown) : '';
            }

            // Scoreboard
            const scoreboard = document.getElementById('scoreboard');
            const sortedPlayers = [...gameState.players].sort((a, b) => b.kills - a.kills);

            scoreboard.innerHTML = sortedPlayers.map((player, index) => {
                const isYou = player.peerId === myId;
                const isLeading = index === 0;
                return `
                    <div class="scoreboard-entry ${isYou ? 'you' : ''} ${isLeading ? 'leading' : ''}">
                        <span>${player.name}</span>
                        <span>${player.kills} / ${player.deaths}</span>
                    </div>
                `;
            }).join('');
        }

        function addKillFeedMessage(killer, victim) {
            const feed = document.getElementById('killFeed');
            const msg = document.createElement('div');
            msg.className = 'kill-message';
            msg.innerHTML = `<strong>${killer}</strong> eliminated <strong>${victim}</strong>`;
            feed.insertBefore(msg, feed.firstChild);

            setTimeout(() => msg.remove(), 3000);

            // Keep only last 5 messages
            while (feed.children.length > 5) {
                feed.removeChild(feed.lastChild);
            }
        }

        // ========================================
        // GAME END
        // ========================================
        function endGame(winner) {
            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }
            if (networkLoop) {
                clearInterval(networkLoop);
                networkLoop = null;
            }

            const gameOver = document.getElementById('gameOver');
            const winnerText = document.getElementById('winnerText');
            const finalStats = document.getElementById('finalStats');

            const isWinner = winner.peerId === myId;
            winnerText.textContent = isWinner ? 'VICTORY!' : 'DEFEAT';
            winnerText.className = `winner-text ${isWinner ? 'victory' : 'defeat'}`;

            // Update player stats
            if (localPlayer) {
                updateMatchStats(
                    localPlayer.kills,
                    localPlayer.deaths,
                    isWinner,
                    localPlayer.heroId,
                    0 // TODO: track healing
                );
            }

            const sortedPlayers = [...gameState.players].sort((a, b) => b.kills - a.kills);

            // Calculate rewards earned
            const killReward = localPlayer ? localPlayer.kills * 10 : 0;
            const matchReward = isWinner ? 50 : 10;
            const totalReward = killReward + matchReward;

            finalStats.innerHTML = `
                <h2>FINAL STANDINGS</h2>
                ${sortedPlayers.map((player, index) => `
                    <div style="padding: 10px; ${index === 0 ? 'color: #f7c531;' : ''} ${player.peerId === myId ? 'background: rgba(78, 205, 196, 0.2);' : ''}">
                        #${index + 1} ${player.name} - ${player.kills} kills / ${player.deaths} deaths
                    </div>
                `).join('')}
                <div style="margin-top: 20px; padding: 15px; border-top: 2px solid #333;">
                    <div style="color: #f7c531; font-size: 18px; font-weight: bold;">REWARDS EARNED</div>
                    <div style="margin-top: 10px; display: flex; justify-content: center; gap: 20px;">
                        <div>üíé ${totalReward}</div>
                    </div>
                </div>
            `;

            gameOver.style.display = 'flex';

            broadcast({ type: 'gameOver', winner: winner });
        }

        // ========================================
        // UTILITY
        // ========================================
        function showLoading(text) {
            document.getElementById('loading').classList.add('active');
            document.getElementById('loadingText').textContent = text;
        }

        function hideLoading() {
            document.getElementById('loading').classList.remove('active');
        }

        function returnToMenu() {
            document.getElementById('game').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('heroSelect').style.display = 'none';
            document.getElementById('menu').style.display = 'flex';
            document.getElementById('currencyDisplay').style.display = 'flex';

            // Update currency display in case it changed
            updateCurrencyDisplay();

            // Stop input sending
            stopInputSending();

            gameState = null;
            currentMap = null;
            roomId = null;

            if (gameLoop) {
                cancelAnimationFrame(gameLoop);
                gameLoop = null;
            }

            // Request latest friends list
            if (isConnected) {
                sendToServer({ type: 'getFriendsList' });
            }
        }

        // Initialize on load
        window.onload = init;
    </script>
</body>
</html>
